<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Agent Interaction Replay — UnrealFrog</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #0f172a;
  --surface: #1e293b;
  --surface2: #273549;
  --border: #334155;
  --text: #f1f5f9;
  --text2: #94a3b8;
  --accent: #3b82f6;
  --glow: rgba(59, 130, 246, 0.4);
}

body {
  font-family: 'SF Mono', 'Cascadia Code', 'Fira Code', 'Consolas', monospace;
  background: var(--bg);
  color: var(--text);
  height: 100vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

/* --- Header --- */
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 20px;
  border-bottom: 1px solid var(--border);
  background: var(--surface);
  flex-shrink: 0;
}
header h1 {
  font-size: 15px;
  font-weight: 600;
  letter-spacing: 1px;
  text-transform: uppercase;
  color: var(--text2);
}
header h1 span { color: var(--accent); }
#transcript-select {
  background: var(--surface2);
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 6px 12px;
  font-family: inherit;
  font-size: 12px;
  max-width: 400px;
  cursor: pointer;
}

/* --- Main Layout --- */
main {
  display: flex;
  flex: 1;
  min-height: 0;
  overflow: hidden;
}

/* --- Arena --- */
#arena-wrap {
  flex: 1;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
}
#arena-canvas {
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  pointer-events: none;
}
.agent-node {
  position: absolute;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
  transform: translate(-50%, -50%);
  transition: opacity 0.3s, filter 0.3s;
  z-index: 2;
}
.agent-node.inactive { opacity: 0.25; filter: grayscale(0.8); }
.agent-avatar {
  width: 56px; height: 56px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  font-weight: 700;
  color: #fff;
  border: 3px solid transparent;
  transition: border-color 0.3s, box-shadow 0.3s;
  position: relative;
}
.agent-node.sender .agent-avatar {
  box-shadow: 0 0 20px var(--agent-color), 0 0 40px var(--agent-color);
  border-color: #fff;
}
.agent-node.receiver .agent-avatar {
  box-shadow: 0 0 14px var(--agent-color);
  border-color: var(--agent-color);
}
.agent-label {
  font-size: 10px;
  color: var(--text2);
  text-align: center;
  white-space: nowrap;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.agent-role {
  font-size: 9px;
  color: var(--text2);
  opacity: 0.6;
  text-align: center;
  white-space: nowrap;
}

/* --- Speech Bubble --- */
#speech-bubble {
  position: absolute;
  max-width: 280px;
  padding: 10px 14px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 10px;
  font-size: 12px;
  line-height: 1.5;
  color: var(--text);
  opacity: 0;
  transform: translate(-50%, -50%) scale(0.9);
  transition: opacity 0.25s, transform 0.25s;
  pointer-events: none;
  z-index: 10;
  box-shadow: 0 4px 24px rgba(0,0,0,0.5);
}
#speech-bubble.visible {
  opacity: 1;
  transform: translate(-50%, -50%) scale(1);
}
#speech-bubble .bubble-from {
  font-size: 10px;
  font-weight: 600;
  margin-bottom: 4px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
#speech-bubble .bubble-text {
  color: var(--text2);
  word-break: break-word;
  max-height: 120px;
  overflow: hidden;
}

/* --- Drop Zone --- */
#drop-zone {
  position: absolute;
  inset: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 16px;
  z-index: 5;
  background: rgba(15, 23, 42, 0.92);
  border: 2px dashed var(--border);
  border-radius: 12px;
  margin: 20px;
}
#drop-zone.hidden { display: none; }
#drop-zone p { color: var(--text2); font-size: 14px; }
#drop-zone .hint { font-size: 11px; color: var(--text2); opacity: 0.6; }
#drop-zone.dragover { border-color: var(--accent); background: rgba(59,130,246,0.08); }
#file-input { display: none; }
#drop-zone button {
  padding: 8px 20px;
  background: var(--accent);
  color: #fff;
  border: none;
  border-radius: 6px;
  font-family: inherit;
  font-size: 12px;
  cursor: pointer;
}

/* --- Side Panel --- */
#panel {
  width: 340px;
  border-left: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  background: var(--surface);
  flex-shrink: 0;
}
#msg-detail {
  padding: 16px;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}
#msg-detail .detail-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}
#msg-detail .detail-counter {
  font-size: 11px;
  color: var(--text2);
}
#msg-detail .detail-time {
  font-size: 11px;
  color: var(--accent);
  font-weight: 600;
}
#msg-detail .detail-route {
  font-size: 13px;
  font-weight: 600;
  margin-bottom: 8px;
}
#msg-detail .detail-route .arrow { color: var(--text2); margin: 0 6px; }
#msg-detail .detail-type {
  display: inline-block;
  font-size: 9px;
  text-transform: uppercase;
  letter-spacing: 1px;
  padding: 2px 8px;
  border-radius: 4px;
  margin-bottom: 10px;
  font-weight: 600;
}
#msg-detail .detail-content {
  font-size: 12px;
  line-height: 1.6;
  color: var(--text2);
  max-height: 200px;
  overflow-y: auto;
  white-space: pre-wrap;
  word-break: break-word;
}
#msg-detail .detail-content::-webkit-scrollbar { width: 4px; }
#msg-detail .detail-content::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

/* --- Message List --- */
#msg-list-wrap {
  flex: 1;
  overflow-y: auto;
  min-height: 0;
}
#msg-list-wrap::-webkit-scrollbar { width: 6px; }
#msg-list-wrap::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
.msg-item {
  display: flex;
  align-items: flex-start;
  gap: 8px;
  padding: 8px 16px;
  cursor: pointer;
  border-bottom: 1px solid rgba(51,65,85,0.3);
  transition: background 0.15s;
  font-size: 11px;
}
.msg-item:hover { background: var(--surface2); }
.msg-item.active { background: rgba(59,130,246,0.12); border-left: 2px solid var(--accent); }
.msg-dot {
  width: 8px; height: 8px;
  border-radius: 50%;
  flex-shrink: 0;
  margin-top: 4px;
}
.msg-item-route { font-weight: 600; white-space: nowrap; }
.msg-item-time { color: var(--text2); margin-left: auto; white-space: nowrap; flex-shrink: 0; }
.msg-item-summary {
  color: var(--text2);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  flex: 1;
  min-width: 0;
}

/* --- Controls --- */
footer {
  border-top: 1px solid var(--border);
  background: var(--surface);
  padding: 10px 20px;
  flex-shrink: 0;
}
#timeline {
  width: 100%;
  height: 6px;
  background: var(--surface2);
  border-radius: 3px;
  cursor: pointer;
  margin-bottom: 10px;
  position: relative;
}
#timeline-fill {
  height: 100%;
  background: var(--accent);
  border-radius: 3px;
  transition: width 0.15s;
}
#timeline-thumb {
  position: absolute;
  top: 50%;
  width: 14px; height: 14px;
  background: #fff;
  border-radius: 50%;
  transform: translate(-50%, -50%);
  box-shadow: 0 1px 4px rgba(0,0,0,0.4);
  transition: left 0.15s;
}
#controls {
  display: flex;
  align-items: center;
  gap: 12px;
}
#controls button {
  background: none;
  border: 1px solid var(--border);
  color: var(--text);
  border-radius: 6px;
  padding: 6px 14px;
  font-family: inherit;
  font-size: 14px;
  cursor: pointer;
  transition: background 0.15s, border-color 0.15s;
}
#controls button:hover { background: var(--surface2); border-color: var(--text2); }
#controls button.playing { background: var(--accent); border-color: var(--accent); }
#counter-label {
  font-size: 12px;
  color: var(--text2);
  min-width: 80px;
  text-align: center;
}
.speed-control {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-left: auto;
  font-size: 11px;
  color: var(--text2);
}
.speed-control input[type=range] {
  width: 100px;
  accent-color: var(--accent);
}
#speed-label { min-width: 32px; text-align: right; font-weight: 600; color: var(--text); }

/* --- Empty State --- */
.empty-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: var(--text2);
  font-size: 13px;
  gap: 8px;
}
.empty-state .big { font-size: 36px; opacity: 0.3; margin-bottom: 8px; }
</style>
</head>
<body>

<header>
  <h1><span>Agent Interaction</span> Replay</h1>
  <select id="transcript-select"><option value="">-- Load transcripts --</option></select>
</header>

<main>
  <div id="arena-wrap">
    <canvas id="arena-canvas"></canvas>
    <div id="speech-bubble">
      <div class="bubble-from"></div>
      <div class="bubble-text"></div>
    </div>
    <div id="drop-zone" class="hidden">
      <p>Drop transcript .md files here</p>
      <button onclick="document.getElementById('file-input').click()">Browse Files</button>
      <input type="file" id="file-input" multiple accept=".md,.json">
      <span class="hint">Or load pre-built data from data/transcripts.json</span>
    </div>
  </div>

  <div id="panel">
    <div id="msg-detail">
      <div class="detail-header">
        <span class="detail-counter" id="detail-counter">No messages</span>
        <span class="detail-time" id="detail-time"></span>
      </div>
      <div class="detail-route" id="detail-route"></div>
      <div class="detail-type" id="detail-type"></div>
      <div class="detail-content" id="detail-content">Select a transcript to begin.</div>
    </div>
    <div id="msg-list-wrap"></div>
  </div>
</main>

<footer>
  <div id="timeline" onclick="handleTimelineClick(event)">
    <div id="timeline-fill"></div>
    <div id="timeline-thumb"></div>
  </div>
  <div id="controls">
    <button id="btn-prev" onclick="stepPrev()" title="Previous message">&lt;</button>
    <button id="btn-play" onclick="togglePlay()" title="Play / Pause">Play</button>
    <button id="btn-next" onclick="stepNext()" title="Next message">&gt;</button>
    <span id="counter-label">0 / 0</span>
    <div class="speed-control">
      <span>Speed</span>
      <input type="range" id="speed-slider" min="0.25" max="4" step="0.25" value="1" oninput="updateSpeed()">
      <span id="speed-label">1x</span>
    </div>
  </div>
</footer>

<script>
// ─── Agent Definitions ───────────────────────────────────────────
const AGENTS = {
  "engine-architect": { initials: "EA", color: "#10B981", label: "Engine Architect", role: "C++ Systems" },
  "game-designer":    { initials: "GD", color: "#F59E0B", label: "Game Designer",    role: "Mechanics" },
  "xp-coach":         { initials: "XP", color: "#3B82F6", label: "XP Coach",         role: "Process" },
  "devops-engineer":  { initials: "DE", color: "#8B5CF6", label: "DevOps Engineer",  role: "Build & CI" },
  "qa-lead":          { initials: "QA", color: "#06B6D4", label: "QA Lead",           role: "Quality" },
  "level-designer":   { initials: "LD", color: "#EF4444", label: "Level Designer",   role: "Spatial" },
  "art-director":     { initials: "AD", color: "#EC4899", label: "Art Director",     role: "Visuals" },
  "sound-engineer":   { initials: "SE", color: "#F97316", label: "Sound Engineer",   role: "Audio" },
  "team-lead":        { initials: "TL", color: "#6366F1", label: "Team Lead",        role: "Coordinator" },
  "user":             { initials: "U",  color: "#94A3B8", label: "Stakeholder",      role: "Direction" },
};

// ─── State ───────────────────────────────────────────────────────
const state = {
  transcripts: [],
  current: null,       // current transcript object
  messages: [],        // messages for current transcript
  index: -1,           // current message index
  playing: false,
  speed: 1,            // multiplier
  baseDelay: 2500,     // ms per message at 1x
  animFrame: null,
  timeout: null,
  agentNodes: {},      // DOM elements keyed by agent id
  agentPositions: {},  // {x, y} keyed by agent id
  participants: [],
};

// ─── Canvas Setup ────────────────────────────────────────────────
const canvas = document.getElementById('arena-canvas');
const ctx = canvas.getContext('2d');
let dpr = window.devicePixelRatio || 1;

function resizeCanvas() {
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  canvas.style.width = rect.width + 'px';
  canvas.style.height = rect.height + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  if (state.current) layoutAgents();
}
window.addEventListener('resize', resizeCanvas);

// ─── Data Loading ────────────────────────────────────────────────
async function loadData() {
  try {
    const resp = await fetch('data/transcripts.json');
    if (!resp.ok) throw new Error('No data file');
    const data = await resp.json();
    if (data.agents) Object.assign(AGENTS, data.agents);
    state.transcripts = data.transcripts || [];
    populateSelector();
    if (state.transcripts.length > 0) {
      document.getElementById('drop-zone').classList.add('hidden');
    } else {
      document.getElementById('drop-zone').classList.remove('hidden');
    }
  } catch {
    document.getElementById('drop-zone').classList.remove('hidden');
  }
}

function populateSelector() {
  const sel = document.getElementById('transcript-select');
  sel.innerHTML = '<option value="">-- Select transcript (' + state.transcripts.length + ' sessions) --</option>';
  for (const t of state.transcripts) {
    const opt = document.createElement('option');
    opt.value = t.id;
    const date = t.metadata?.date || '';
    const count = t.messageCount || 0;
    opt.textContent = `${date} — ${t.title} (${count} msgs)`;
    sel.appendChild(opt);
  }
  sel.onchange = () => {
    const t = state.transcripts.find(x => x.id === sel.value);
    if (t) loadTranscript(t);
  };
}

// ─── File Drop/Upload ────────────────────────────────────────────
const dropZone = document.getElementById('drop-zone');
const fileInput = document.getElementById('file-input');

document.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
document.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
document.addEventListener('drop', e => {
  e.preventDefault();
  dropZone.classList.remove('dragover');
  handleFiles(e.dataTransfer.files);
});
fileInput.addEventListener('change', () => handleFiles(fileInput.files));

function handleFiles(files) {
  for (const file of files) {
    const reader = new FileReader();
    reader.onload = e => {
      const text = e.target.result;
      if (file.name.endsWith('.json')) {
        try {
          const data = JSON.parse(text);
          const list = data.transcripts || [data];
          state.transcripts.push(...list);
          populateSelector();
          dropZone.classList.add('hidden');
        } catch {}
      } else {
        const t = parseTranscriptMd(text, file.name);
        if (t && t.messages.length > 0) {
          state.transcripts.push(t);
          populateSelector();
          dropZone.classList.add('hidden');
        }
      }
    };
    reader.readAsText(file);
  }
}

function parseTranscriptMd(text, filename) {
  const messages = [];
  const sections = text.split(/^(## (?:User|Assistant) \(\d{2}:\d{2} UTC\))/m);
  let lastTeammate = null;

  for (let i = 1; i < sections.length; i += 2) {
    const header = sections[i];
    const body = sections[i + 1] || '';
    const hm = header.match(/## (User|Assistant) \((\d{2}:\d{2}) UTC\)/);
    if (!hm) continue;
    const [, role, time] = hm;

    const tm = body.match(/<teammate-message\s+teammate_id="([^"]+)"(?:\s+color="[^"]*")?(?:\s+summary="([^"]*)")?\s*>/);

    if (role === 'User' && tm) {
      const sender = tm[1], summary = tm[2] || '';
      const cm = body.match(/<teammate-message[^>]*>([\s\S]*?)<\/teammate-message>/);
      const content = cm ? cm[1].trim() : body.trim();
      let receiver = 'team-lead';
      const toM = summary.match(/\[to\s+([a-z][\w-]*)\]/i);
      if (toM) receiver = toM[1];
      const mtype = content.includes('"type": "idle_notification"') ? 'idle' : 'teammate';
      messages.push({ time, from: sender, to: receiver, content: content.slice(0, 800), summary, type: mtype });
      lastTeammate = sender;
    } else if (role === 'User') {
      const content = body.trim();
      if (content.length > 10) {
        messages.push({ time, from: 'user', to: 'team-lead', content: content.slice(0, 800), summary: '', type: 'user' });
        lastTeammate = null;
      }
    } else if (role === 'Assistant') {
      const lines = body.split('\n').filter(l => l.trim() && !l.trim().startsWith('- **Used'));
      if (lines.length > 0) {
        const receiver = lastTeammate || 'all';
        const mtype = body.includes('**Used SendMessage**') ? 'send' : 'response';
        messages.push({ time, from: 'team-lead', to: receiver, content: lines.join('\n').slice(0, 800), summary: '', type: mtype });
      }
    }
  }

  const name = filename.replace('.md', '');
  const participants = [...new Set(messages.flatMap(m => [m.from, ...(m.to !== 'all' ? [m.to] : [])]))];
  return {
    id: name, title: name.split('-').slice(4).join(' ') || name,
    metadata: {}, messages, participants, messageCount: messages.length
  };
}

// ─── Load Transcript ─────────────────────────────────────────────
function loadTranscript(t) {
  stop();
  state.current = t;
  state.messages = t.messages;
  state.index = -1;
  state.participants = t.participants.filter(p => p in AGENTS);

  // Ensure team-lead is included if any teammate messages exist
  if (state.messages.some(m => m.type === 'teammate' || m.type === 'response') && !state.participants.includes('team-lead')) {
    state.participants.push('team-lead');
  }

  layoutAgents();
  renderMessageList();
  updateUI();
  clearCanvas();
}

// ─── Layout Agents in Circle ─────────────────────────────────────
function layoutAgents() {
  // Remove existing nodes
  Object.values(state.agentNodes).forEach(n => n.remove());
  state.agentNodes = {};
  state.agentPositions = {};

  const wrap = document.getElementById('arena-wrap');
  const rect = wrap.getBoundingClientRect();
  const cx = rect.width / 2;
  const cy = rect.height / 2;
  const radius = Math.min(cx, cy) * 0.62;

  const allAgents = Object.keys(AGENTS);
  const activeSet = new Set(state.participants);
  const display = allAgents.filter(a => activeSet.has(a));
  const count = display.length;

  display.forEach((id, i) => {
    const angle = (i / count) * Math.PI * 2 - Math.PI / 2;
    const x = cx + Math.cos(angle) * radius;
    const y = cy + Math.sin(angle) * radius;
    state.agentPositions[id] = { x, y };

    const agent = AGENTS[id];
    const node = document.createElement('div');
    node.className = 'agent-node';
    node.style.left = x + 'px';
    node.style.top = y + 'px';
    node.style.setProperty('--agent-color', agent.color);
    node.dataset.agentId = id;

    const avatar = document.createElement('div');
    avatar.className = 'agent-avatar';
    avatar.style.background = agent.color + '22';
    avatar.style.borderColor = agent.color + '66';
    avatar.style.color = agent.color;
    avatar.textContent = agent.initials;

    const label = document.createElement('div');
    label.className = 'agent-label';
    label.textContent = agent.label;

    const role = document.createElement('div');
    role.className = 'agent-role';
    role.textContent = agent.role;

    node.appendChild(avatar);
    node.appendChild(label);
    node.appendChild(role);
    wrap.appendChild(node);
    state.agentNodes[id] = node;
  });
}

// ─── Canvas Drawing ──────────────────────────────────────────────
function clearCanvas() {
  const rect = canvas.parentElement.getBoundingClientRect();
  ctx.clearRect(0, 0, rect.width, rect.height);
}

function getControlPoint(from, to, cx, cy) {
  const mx = (from.x + to.x) / 2;
  const my = (from.y + to.y) / 2;
  const pull = 0.35;
  return { x: mx + (cx - mx) * pull, y: my + (cy - my) * pull };
}

function drawArc(fromPos, toPos, progress, color) {
  const rect = canvas.parentElement.getBoundingClientRect();
  const cx = rect.width / 2, cy = rect.height / 2;
  const cp = getControlPoint(fromPos, toPos, cx, cy);

  clearCanvas();

  // Draw the arc trail
  ctx.beginPath();
  ctx.moveTo(fromPos.x, fromPos.y);
  ctx.quadraticCurveTo(cp.x, cp.y, toPos.x, toPos.y);
  ctx.strokeStyle = color + '18';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Draw the animated portion
  if (progress > 0) {
    const steps = 60;
    const endStep = Math.floor(progress * steps);
    ctx.beginPath();
    for (let s = 0; s <= endStep; s++) {
      const t = s / steps;
      const x = (1 - t) * (1 - t) * fromPos.x + 2 * (1 - t) * t * cp.x + t * t * toPos.x;
      const y = (1 - t) * (1 - t) * fromPos.y + 2 * (1 - t) * t * cp.y + t * t * toPos.y;
      if (s === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.strokeStyle = color;
    ctx.lineWidth = 2.5;
    ctx.shadowColor = color;
    ctx.shadowBlur = 8;
    ctx.stroke();
    ctx.shadowBlur = 0;

    // Dot at the leading edge
    const t = progress;
    const dotX = (1 - t) * (1 - t) * fromPos.x + 2 * (1 - t) * t * cp.x + t * t * toPos.x;
    const dotY = (1 - t) * (1 - t) * fromPos.y + 2 * (1 - t) * t * cp.y + t * t * toPos.y;
    ctx.beginPath();
    ctx.arc(dotX, dotY, 5, 0, Math.PI * 2);
    ctx.fillStyle = '#fff';
    ctx.shadowColor = color;
    ctx.shadowBlur = 12;
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

// ─── Speech Bubble ───────────────────────────────────────────────
const bubble = document.getElementById('speech-bubble');

function showBubble(msg, receiverPos) {
  if (!receiverPos) { hideBubble(); return; }
  const agent = AGENTS[msg.from];
  bubble.querySelector('.bubble-from').textContent = agent?.label || msg.from;
  bubble.querySelector('.bubble-from').style.color = agent?.color || '#fff';

  const text = msg.summary || msg.content.slice(0, 160);
  bubble.querySelector('.bubble-text').textContent = text + (msg.content.length > 160 && !msg.summary ? '...' : '');

  const wrap = document.getElementById('arena-wrap').getBoundingClientRect();
  // Position near receiver, offset toward center
  const cx = wrap.width / 2, cy = wrap.height / 2;
  const dx = cx - receiverPos.x, dy = cy - receiverPos.y;
  const dist = Math.sqrt(dx * dx + dy * dy) || 1;
  const offsetX = (dx / dist) * 70;
  const offsetY = (dy / dist) * 70;

  bubble.style.left = (receiverPos.x + offsetX) + 'px';
  bubble.style.top = (receiverPos.y + offsetY) + 'px';
  bubble.style.borderColor = agent?.color || var('--border');
  bubble.classList.add('visible');
}

function hideBubble() {
  bubble.classList.remove('visible');
}

// ─── Animation ───────────────────────────────────────────────────
function animateMessage(index) {
  const msg = state.messages[index];
  if (!msg) return;

  state.index = index;
  updateUI();

  // Highlight sender/receiver
  Object.values(state.agentNodes).forEach(n => n.classList.remove('sender', 'receiver'));
  if (state.agentNodes[msg.from]) state.agentNodes[msg.from].classList.add('sender');
  const toId = msg.to === 'all' ? null : msg.to;
  if (toId && state.agentNodes[toId]) state.agentNodes[toId].classList.add('receiver');

  const fromPos = state.agentPositions[msg.from];
  const toPos = toId ? state.agentPositions[toId] : null;
  const color = AGENTS[msg.from]?.color || '#fff';

  if (!fromPos || !toPos) {
    // No arc to draw (broadcast or unknown agent) — just show the bubble
    clearCanvas();
    if (fromPos) showBubble(msg, fromPos);
    scheduleNext();
    return;
  }

  // Animate the arc over the first 40% of the message duration
  const arcDuration = (state.baseDelay / state.speed) * 0.4;
  const startTime = performance.now();

  function frame(now) {
    const elapsed = now - startTime;
    const progress = Math.min(elapsed / arcDuration, 1);
    drawArc(fromPos, toPos, progress, color);

    if (progress >= 0.7 && !bubble.classList.contains('visible')) {
      showBubble(msg, toPos);
    }

    if (progress < 1) {
      state.animFrame = requestAnimationFrame(frame);
    } else {
      showBubble(msg, toPos);
      scheduleNext();
    }
  }

  cancelAnimationFrame(state.animFrame);
  clearTimeout(state.timeout);
  state.animFrame = requestAnimationFrame(frame);
}

function scheduleNext() {
  if (!state.playing) return;
  const holdDuration = (state.baseDelay / state.speed) * 0.6;
  state.timeout = setTimeout(() => {
    if (state.index < state.messages.length - 1) {
      animateMessage(state.index + 1);
    } else {
      stop();
    }
  }, holdDuration);
}

// ─── Playback Controls ──────────────────────────────────────────
function togglePlay() {
  if (state.playing) { pause(); } else { play(); }
}

function play() {
  if (!state.current || state.messages.length === 0) return;
  state.playing = true;
  document.getElementById('btn-play').textContent = 'Pause';
  document.getElementById('btn-play').classList.add('playing');
  const startIdx = state.index < 0 ? 0 : (state.index >= state.messages.length - 1 ? 0 : state.index + 1);
  animateMessage(startIdx);
}

function pause() {
  state.playing = false;
  cancelAnimationFrame(state.animFrame);
  clearTimeout(state.timeout);
  document.getElementById('btn-play').textContent = 'Play';
  document.getElementById('btn-play').classList.remove('playing');
}

function stop() {
  pause();
  hideBubble();
}

function stepNext() {
  pause();
  if (!state.current) return;
  const next = Math.min(state.index + 1, state.messages.length - 1);
  showMessageStatic(next);
}

function stepPrev() {
  pause();
  if (!state.current) return;
  const prev = Math.max(state.index - 1, 0);
  showMessageStatic(prev);
}

function showMessageStatic(index) {
  const msg = state.messages[index];
  if (!msg) return;
  state.index = index;

  Object.values(state.agentNodes).forEach(n => n.classList.remove('sender', 'receiver'));
  if (state.agentNodes[msg.from]) state.agentNodes[msg.from].classList.add('sender');
  const toId = msg.to === 'all' ? null : msg.to;
  if (toId && state.agentNodes[toId]) state.agentNodes[toId].classList.add('receiver');

  const fromPos = state.agentPositions[msg.from];
  const toPos = toId ? state.agentPositions[toId] : null;
  const color = AGENTS[msg.from]?.color || '#fff';

  if (fromPos && toPos) {
    drawArc(fromPos, toPos, 1, color);
    showBubble(msg, toPos);
  } else if (fromPos) {
    clearCanvas();
    showBubble(msg, fromPos);
  } else {
    clearCanvas();
    hideBubble();
  }

  updateUI();
}

function jumpTo(index) {
  pause();
  showMessageStatic(index);
}

function updateSpeed() {
  const slider = document.getElementById('speed-slider');
  state.speed = parseFloat(slider.value);
  document.getElementById('speed-label').textContent = state.speed + 'x';
}

function handleTimelineClick(e) {
  if (!state.current || state.messages.length === 0) return;
  const rect = e.currentTarget.getBoundingClientRect();
  const pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
  const idx = Math.round(pct * (state.messages.length - 1));
  pause();
  showMessageStatic(idx);
}

// ─── UI Updates ──────────────────────────────────────────────────
function updateUI() {
  const total = state.messages.length;
  const idx = state.index;

  // Counter
  document.getElementById('counter-label').textContent = (idx >= 0 ? idx + 1 : 0) + ' / ' + total;
  document.getElementById('detail-counter').textContent = 'Message ' + (idx >= 0 ? idx + 1 : '-') + ' of ' + total;

  // Timeline
  const pct = total > 0 && idx >= 0 ? ((idx / (total - 1)) * 100) : 0;
  document.getElementById('timeline-fill').style.width = pct + '%';
  document.getElementById('timeline-thumb').style.left = pct + '%';

  // Message detail
  if (idx >= 0 && idx < total) {
    const msg = state.messages[idx];
    const fromAgent = AGENTS[msg.from];
    const toAgent = AGENTS[msg.to];

    document.getElementById('detail-time').textContent = msg.time + ' UTC';

    const routeEl = document.getElementById('detail-route');
    routeEl.innerHTML = '';
    const fromSpan = document.createElement('span');
    fromSpan.style.color = fromAgent?.color || '#fff';
    fromSpan.textContent = fromAgent?.label || msg.from;
    const arrow = document.createElement('span');
    arrow.className = 'arrow';
    arrow.textContent = ' \u2192 ';
    const toSpan = document.createElement('span');
    toSpan.style.color = toAgent?.color || '#fff';
    toSpan.textContent = msg.to === 'all' ? 'All' : (toAgent?.label || msg.to);
    routeEl.append(fromSpan, arrow, toSpan);

    const typeEl = document.getElementById('detail-type');
    const typeColors = {
      teammate: '#10B981', response: '#6366F1', user: '#94A3B8',
      idle: '#475569', send: '#F59E0B'
    };
    typeEl.style.background = (typeColors[msg.type] || '#475569') + '33';
    typeEl.style.color = typeColors[msg.type] || '#94A3B8';
    typeEl.textContent = msg.type;

    document.getElementById('detail-content').textContent = msg.content;

    // Highlight in list
    document.querySelectorAll('.msg-item').forEach((el, i) => {
      el.classList.toggle('active', i === idx);
    });
    const activeItem = document.querySelector('.msg-item.active');
    if (activeItem) activeItem.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
  }
}

function renderMessageList() {
  const wrap = document.getElementById('msg-list-wrap');
  wrap.innerHTML = '';

  state.messages.forEach((msg, i) => {
    const item = document.createElement('div');
    item.className = 'msg-item';
    item.onclick = () => jumpTo(i);

    const dot = document.createElement('div');
    dot.className = 'msg-dot';
    dot.style.background = AGENTS[msg.from]?.color || '#666';

    const route = document.createElement('span');
    route.className = 'msg-item-route';
    const fromInit = AGENTS[msg.from]?.initials || '?';
    const toInit = msg.to === 'all' ? 'ALL' : (AGENTS[msg.to]?.initials || '?');
    route.textContent = fromInit + '\u2192' + toInit;
    route.style.color = AGENTS[msg.from]?.color || '#fff';

    const summary = document.createElement('span');
    summary.className = 'msg-item-summary';
    summary.textContent = msg.summary || msg.content.slice(0, 60).replace(/\n/g, ' ');

    const time = document.createElement('span');
    time.className = 'msg-item-time';
    time.textContent = msg.time;

    item.append(dot, route, summary, time);
    wrap.appendChild(item);
  });
}

// ─── Keyboard Shortcuts ──────────────────────────────────────────
document.addEventListener('keydown', e => {
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
  switch (e.key) {
    case ' ': e.preventDefault(); togglePlay(); break;
    case 'ArrowRight': case 'l': stepNext(); break;
    case 'ArrowLeft': case 'h': stepPrev(); break;
    case 'ArrowUp': case 'k':
      e.preventDefault();
      document.getElementById('speed-slider').stepUp();
      updateSpeed();
      break;
    case 'ArrowDown': case 'j':
      e.preventDefault();
      document.getElementById('speed-slider').stepDown();
      updateSpeed();
      break;
  }
});

// ─── Init ────────────────────────────────────────────────────────
resizeCanvas();
loadData();
</script>
</body>
</html>
