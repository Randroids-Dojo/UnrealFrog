<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Agent Interaction Replay — UnrealFrog</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #0f172a;
  --surface: #1e293b;
  --surface2: #273549;
  --border: #334155;
  --text: #f1f5f9;
  --text2: #94a3b8;
  --accent: #3b82f6;
  --glow: rgba(59, 130, 246, 0.4);
}

body {
  font-family: 'SF Mono', 'Cascadia Code', 'Fira Code', 'Consolas', monospace;
  background: var(--bg);
  color: var(--text);
  height: 100vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

/* --- Header --- */
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 20px;
  border-bottom: 1px solid var(--border);
  background: var(--surface);
  flex-shrink: 0;
  gap: 16px;
}
header h1 {
  font-size: 15px;
  font-weight: 600;
  letter-spacing: 1px;
  text-transform: uppercase;
  color: var(--text2);
  white-space: nowrap;
}
header h1 span { color: var(--accent); }
#session-info {
  font-size: 11px;
  color: var(--text2);
  white-space: nowrap;
}
#transcript-select {
  background: var(--surface2);
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 6px 12px;
  font-family: inherit;
  font-size: 12px;
  max-width: 500px;
  flex: 1;
  cursor: pointer;
}

/* --- Main Layout --- */
main {
  display: flex;
  flex: 1;
  min-height: 0;
  overflow: hidden;
}

/* --- Arena --- */
#arena-wrap {
  flex: 1;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
}
#arena-canvas {
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  pointer-events: none;
}
.agent-node {
  position: absolute;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  transform: translate(-50%, -50%);
  transition: opacity 0.3s, filter 0.3s;
  z-index: 2;
}
.agent-node.inactive { opacity: 0.25; filter: grayscale(0.8); }
.agent-avatar {
  width: 60px; height: 60px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 3px solid transparent;
  transition: border-color 0.3s, box-shadow 0.3s;
  position: relative;
  overflow: hidden;
}
.agent-avatar svg {
  width: 34px; height: 34px;
}
.agent-node.sender .agent-avatar {
  box-shadow: 0 0 20px var(--agent-color), 0 0 40px var(--agent-color);
  border-color: #fff;
}
.agent-node.receiver .agent-avatar {
  box-shadow: 0 0 14px var(--agent-color);
  border-color: var(--agent-color);
}
.agent-label {
  font-size: 10px;
  color: var(--text2);
  text-align: center;
  white-space: nowrap;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.agent-role {
  font-size: 9px;
  color: var(--text2);
  opacity: 0.6;
  text-align: center;
  white-space: nowrap;
}

/* --- Speech Bubble --- */
#speech-bubble {
  position: absolute;
  max-width: 280px;
  padding: 10px 14px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 10px;
  font-size: 12px;
  line-height: 1.5;
  color: var(--text);
  opacity: 0;
  transform: translate(-50%, -50%) scale(0.9);
  transition: opacity 0.25s, transform 0.25s;
  pointer-events: none;
  z-index: 10;
  box-shadow: 0 4px 24px rgba(0,0,0,0.5);
}
#speech-bubble.visible {
  opacity: 1;
  transform: translate(-50%, -50%) scale(1);
}
#speech-bubble .bubble-from {
  font-size: 10px;
  font-weight: 600;
  margin-bottom: 4px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
#speech-bubble .bubble-text {
  color: var(--text2);
  word-break: break-word;
  max-height: 120px;
  overflow: hidden;
}

/* --- Drop Zone --- */
#drop-zone {
  position: absolute;
  inset: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 16px;
  z-index: 5;
  background: rgba(15, 23, 42, 0.92);
  border: 2px dashed var(--border);
  border-radius: 12px;
  margin: 20px;
}
#drop-zone.hidden { display: none; }
#drop-zone p { color: var(--text2); font-size: 14px; }
#drop-zone .hint { font-size: 11px; color: var(--text2); opacity: 0.6; }
#drop-zone.dragover { border-color: var(--accent); background: rgba(59,130,246,0.08); }
#file-input { display: none; }
#drop-zone button {
  padding: 8px 20px;
  background: var(--accent);
  color: #fff;
  border: none;
  border-radius: 6px;
  font-family: inherit;
  font-size: 12px;
  cursor: pointer;
}

/* --- Side Panel --- */
#panel {
  width: 340px;
  border-left: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  background: var(--surface);
  flex-shrink: 0;
}
#msg-detail {
  padding: 16px;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}
#msg-detail .detail-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}
#msg-detail .detail-counter {
  font-size: 11px;
  color: var(--text2);
}
#msg-detail .detail-time {
  font-size: 11px;
  color: var(--accent);
  font-weight: 600;
}
#msg-detail .detail-route {
  font-size: 13px;
  font-weight: 600;
  margin-bottom: 8px;
}
#msg-detail .detail-route .arrow { color: var(--text2); margin: 0 6px; }
#msg-detail .detail-type {
  display: inline-block;
  font-size: 9px;
  text-transform: uppercase;
  letter-spacing: 1px;
  padding: 2px 8px;
  border-radius: 4px;
  margin-bottom: 10px;
  font-weight: 600;
}
#msg-detail .detail-content {
  font-size: 12px;
  line-height: 1.6;
  color: var(--text2);
  max-height: 200px;
  overflow-y: auto;
  white-space: pre-wrap;
  word-break: break-word;
}
#msg-detail .detail-content::-webkit-scrollbar { width: 4px; }
#msg-detail .detail-content::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

/* --- Message List --- */
#msg-list-wrap {
  flex: 1;
  overflow-y: auto;
  min-height: 0;
}
#msg-list-wrap::-webkit-scrollbar { width: 6px; }
#msg-list-wrap::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
.msg-item {
  display: flex;
  align-items: flex-start;
  gap: 8px;
  padding: 8px 16px;
  cursor: pointer;
  border-bottom: 1px solid rgba(51,65,85,0.3);
  transition: background 0.15s;
  font-size: 11px;
}
.msg-item:hover { background: var(--surface2); }
.msg-item.active { background: rgba(59,130,246,0.12); border-left: 2px solid var(--accent); }
.msg-dot {
  width: 8px; height: 8px;
  border-radius: 50%;
  flex-shrink: 0;
  margin-top: 4px;
}
.msg-item-route { font-weight: 600; white-space: nowrap; }
.msg-item-time { color: var(--text2); margin-left: auto; white-space: nowrap; flex-shrink: 0; }
.msg-item-summary {
  color: var(--text2);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  flex: 1;
  min-width: 0;
}
.msg-self-badge {
  font-size: 8px;
  background: rgba(99,102,241,0.2);
  color: #a5b4fc;
  padding: 1px 5px;
  border-radius: 3px;
  margin-left: 4px;
  flex-shrink: 0;
}

/* --- Controls --- */
footer {
  border-top: 1px solid var(--border);
  background: var(--surface);
  padding: 10px 20px;
  flex-shrink: 0;
}
#timeline {
  width: 100%;
  height: 6px;
  background: var(--surface2);
  border-radius: 3px;
  cursor: pointer;
  margin-bottom: 10px;
  position: relative;
}
#timeline-fill {
  height: 100%;
  background: var(--accent);
  border-radius: 3px;
  transition: width 0.15s;
}
#timeline-thumb {
  position: absolute;
  top: 50%;
  width: 14px; height: 14px;
  background: #fff;
  border-radius: 50%;
  transform: translate(-50%, -50%);
  box-shadow: 0 1px 4px rgba(0,0,0,0.4);
  transition: left 0.15s;
}
#controls {
  display: flex;
  align-items: center;
  gap: 12px;
}
#controls button {
  background: none;
  border: 1px solid var(--border);
  color: var(--text);
  border-radius: 6px;
  padding: 6px 14px;
  font-family: inherit;
  font-size: 14px;
  cursor: pointer;
  transition: background 0.15s, border-color 0.15s;
}
#controls button:hover { background: var(--surface2); border-color: var(--text2); }
#controls button.playing { background: var(--accent); border-color: var(--accent); }
#counter-label {
  font-size: 12px;
  color: var(--text2);
  min-width: 80px;
  text-align: center;
}
.speed-control {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-left: auto;
  font-size: 11px;
  color: var(--text2);
}
.speed-control input[type=range] {
  width: 100px;
  accent-color: var(--accent);
}
#speed-label { min-width: 32px; text-align: right; font-weight: 600; color: var(--text); }

/* --- Empty State --- */
.empty-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: var(--text2);
  font-size: 13px;
  gap: 8px;
}
.empty-state .big { font-size: 36px; opacity: 0.3; margin-bottom: 8px; }
</style>
</head>
<body>

<header>
  <h1><span>Agent Interaction</span> Replay</h1>
  <select id="transcript-select"><option value="">-- Loading... --</option></select>
  <span id="session-info"></span>
</header>

<main>
  <div id="arena-wrap">
    <canvas id="arena-canvas"></canvas>
    <div id="speech-bubble">
      <div class="bubble-from"></div>
      <div class="bubble-text"></div>
    </div>
    <div id="drop-zone" class="hidden">
      <p>Drop transcript .md files here</p>
      <button onclick="document.getElementById('file-input').click()">Browse Files</button>
      <input type="file" id="file-input" multiple accept=".md,.json">
      <span class="hint">Or load pre-built data from data/transcripts.json</span>
    </div>
  </div>

  <div id="panel">
    <div id="msg-detail">
      <div class="detail-header">
        <span class="detail-counter" id="detail-counter">No messages</span>
        <span class="detail-time" id="detail-time"></span>
      </div>
      <div class="detail-route" id="detail-route"></div>
      <div class="detail-type" id="detail-type"></div>
      <div class="detail-content" id="detail-content">Select a session to begin.</div>
    </div>
    <div id="msg-list-wrap"></div>
  </div>
</main>

<footer>
  <div id="timeline" onclick="handleTimelineClick(event)">
    <div id="timeline-fill"></div>
    <div id="timeline-thumb"></div>
  </div>
  <div id="controls">
    <button id="btn-prev" onclick="stepPrev()" title="Previous message">&lt;</button>
    <button id="btn-play" onclick="togglePlay()" title="Play / Pause">Play</button>
    <button id="btn-next" onclick="stepNext()" title="Next message">&gt;</button>
    <span id="counter-label">0 / 0</span>
    <div class="speed-control">
      <span>Speed</span>
      <input type="range" id="speed-slider" min="0.25" max="4" step="0.25" value="1" oninput="updateSpeed()">
      <span id="speed-label">1x</span>
    </div>
  </div>
</footer>

<script>
// ─── SVG Icons for Agent Avatars ─────────────────────────────────
// Each icon is an SVG path string drawn in a 24x24 viewBox
const AGENT_ICONS = {
  "engine-architect": // Gear
    '<path d="M12 15.5A3.5 3.5 0 1 0 12 8.5a3.5 3.5 0 0 0 0 7zm7.43-2.53l1.57-.27V11.3l-1.57-.27a7.04 7.04 0 0 0-.6-1.46l.93-1.27-1.06-1.06-1.27.93a7.04 7.04 0 0 0-1.46-.6L16.7 6h-1.4l-.27 1.57a7.04 7.04 0 0 0-1.46.6l-1.27-.93-1.06 1.06.93 1.27a7.04 7.04 0 0 0-.6 1.46L10 11.3v1.4l1.57.27c.14.52.34 1.01.6 1.46l-.93 1.27 1.06 1.06 1.27-.93c.45.26.94.46 1.46.6L15.3 18h1.4l.27-1.57a7.04 7.04 0 0 0 1.46-.6l1.27.93 1.06-1.06-.93-1.27c.26-.45.46-.94.6-1.46z" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/>',
  "game-designer": // Gamepad
    '<path d="M6 11h4M8 9v4M15 12h.01M18 10h.01" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><path d="M17.32 5H6.68a2 2 0 0 0-1.95 1.55L3 14a3 3 0 0 0 5.83 1l.34-1h5.66l.34 1A3 3 0 0 0 21 14l-1.73-7.45A2 2 0 0 0 17.32 5z" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/>',
  "xp-coach": // Clipboard with check
    '<path d="M9 5H7a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2h-2" fill="none" stroke="currentColor" stroke-width="1.5"/><rect x="9" y="3" width="6" height="4" rx="1" fill="none" stroke="currentColor" stroke-width="1.5"/><path d="M9 14l2 2 4-4" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>',
  "devops-engineer": // Wrench
    '<path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/>',
  "qa-lead": // Magnifying glass with bug
    '<circle cx="11" cy="11" r="7" fill="none" stroke="currentColor" stroke-width="1.5"/><path d="M21 21l-4.35-4.35" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><circle cx="11" cy="11" r="2.5" fill="none" stroke="currentColor" stroke-width="1.2"/><path d="M11 8.5v-1M9 10h-1M13 10h1M11 13.5v1" stroke="currentColor" stroke-width="1" stroke-linecap="round"/>',
  "level-designer": // Grid/Map
    '<rect x="3" y="3" width="18" height="18" rx="2" fill="none" stroke="currentColor" stroke-width="1.5"/><path d="M3 9h18M3 15h18M9 3v18M15 3v18" stroke="currentColor" stroke-width="1" opacity="0.6"/><path d="M6 6l3 3M15 6l3 3M6 15l3 3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>',
  "art-director": // Palette
    '<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10c.83 0 1.5-.67 1.5-1.5 0-.39-.15-.74-.39-1.01-.23-.26-.38-.61-.38-1 0-.83.67-1.5 1.5-1.5H16c3.31 0 6-2.69 6-6 0-4.97-4.48-9-10-9z" fill="none" stroke="currentColor" stroke-width="1.5"/><circle cx="7.5" cy="11.5" r="1.5" fill="currentColor"/><circle cx="10.5" cy="7.5" r="1.5" fill="currentColor"/><circle cx="14.5" cy="7.5" r="1.5" fill="currentColor"/><circle cx="17.5" cy="11.5" r="1.5" fill="currentColor"/>',
  "sound-engineer": // Waveform
    '<path d="M12 3v18M8 7v10M4 10v4M16 7v10M20 10v4" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>',
  "team-lead": // Crown/Star
    '<path d="M12 2l2.4 7.4H22l-6.2 4.5 2.4 7.4L12 16.8l-6.2 4.5 2.4-7.4L2 9.4h7.6z" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/>',
  "user": // Person
    '<circle cx="12" cy="8" r="4" fill="none" stroke="currentColor" stroke-width="1.5"/><path d="M20 21a8 8 0 0 0-16 0" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>',
};
// Fallback for unknown agents
const FALLBACK_ICON = '<circle cx="12" cy="12" r="6" fill="none" stroke="currentColor" stroke-width="1.5"/><text x="12" y="15" text-anchor="middle" font-size="8" fill="currentColor">?</text>';

// ─── Agent Definitions ───────────────────────────────────────────
const AGENTS = {
  "engine-architect": { initials: "EA", color: "#10B981", label: "Engine Architect", role: "C++ Systems" },
  "game-designer":    { initials: "GD", color: "#F59E0B", label: "Game Designer",    role: "Mechanics" },
  "xp-coach":         { initials: "XP", color: "#3B82F6", label: "XP Coach",         role: "Process" },
  "devops-engineer":  { initials: "DE", color: "#8B5CF6", label: "DevOps Engineer",  role: "Build & CI" },
  "qa-lead":          { initials: "QA", color: "#06B6D4", label: "QA Lead",           role: "Quality" },
  "level-designer":   { initials: "LD", color: "#EF4444", label: "Level Designer",   role: "Spatial" },
  "art-director":     { initials: "AD", color: "#EC4899", label: "Art Director",     role: "Visuals" },
  "sound-engineer":   { initials: "SE", color: "#F97316", label: "Sound Engineer",   role: "Audio" },
  "team-lead":        { initials: "TL", color: "#6366F1", label: "Team Lead",        role: "Coordinator" },
  "user":             { initials: "U",  color: "#94A3B8", label: "Stakeholder",      role: "Direction" },
};

// ─── State ───────────────────────────────────────────────────────
const state = {
  transcripts: [],
  current: null,
  messages: [],
  index: -1,
  playing: false,
  speed: 1,
  baseDelay: 2500,
  animFrame: null,
  timeout: null,
  agentNodes: {},
  agentPositions: {},
  participants: [],
};

// ─── Canvas Setup ────────────────────────────────────────────────
const canvas = document.getElementById('arena-canvas');
const ctx = canvas.getContext('2d');
let dpr = window.devicePixelRatio || 1;

function resizeCanvas() {
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  canvas.style.width = rect.width + 'px';
  canvas.style.height = rect.height + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  if (state.current) layoutAgents();
}
window.addEventListener('resize', resizeCanvas);

// ─── Data Loading ────────────────────────────────────────────────
async function loadData() {
  try {
    const resp = await fetch('data/transcripts.json');
    if (!resp.ok) throw new Error('No data file');
    const data = await resp.json();
    if (data.agents) Object.assign(AGENTS, data.agents);
    state.transcripts = data.transcripts || [];
    populateSelector();
    if (state.transcripts.length > 0) {
      document.getElementById('drop-zone').classList.add('hidden');
    } else {
      document.getElementById('drop-zone').classList.remove('hidden');
    }
  } catch {
    document.getElementById('drop-zone').classList.remove('hidden');
  }
}

function populateSelector() {
  const sel = document.getElementById('transcript-select');
  sel.innerHTML = '<option value="">-- Select session (' + state.transcripts.length + ') --</option>';
  for (const t of state.transcripts) {
    const opt = document.createElement('option');
    opt.value = t.id;
    const date = t.metadata?.date || '';
    const msgs = t.messageCount || 0;
    const files = t.fileCount || 1;
    const agents = (t.participants || []).filter(p => p in AGENTS && p !== 'team-lead' && p !== 'user' && p !== 'system').length;
    opt.textContent = date + ' \u2014 ' + t.title + ' (' + msgs + ' msgs, ' + agents + ' agents)';
    sel.appendChild(opt);
  }
  sel.onchange = () => {
    const t = state.transcripts.find(x => x.id === sel.value);
    if (t) loadTranscript(t);
  };
}

// ─── File Drop/Upload ────────────────────────────────────────────
const dropZone = document.getElementById('drop-zone');
const fileInput = document.getElementById('file-input');

document.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
document.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
document.addEventListener('drop', e => {
  e.preventDefault();
  dropZone.classList.remove('dragover');
  handleFiles(e.dataTransfer.files);
});
fileInput.addEventListener('change', () => handleFiles(fileInput.files));

function handleFiles(files) {
  for (const file of files) {
    const reader = new FileReader();
    reader.onload = e => {
      const text = e.target.result;
      if (file.name.endsWith('.json')) {
        try {
          const data = JSON.parse(text);
          const list = data.transcripts || [data];
          state.transcripts.push(...list);
          populateSelector();
          dropZone.classList.add('hidden');
        } catch {}
      } else {
        const t = parseTranscriptMd(text, file.name);
        if (t && t.messages.length > 0) {
          state.transcripts.push(t);
          populateSelector();
          dropZone.classList.add('hidden');
        }
      }
    };
    reader.readAsText(file);
  }
}

function parseTranscriptMd(text, filename) {
  const messages = [];
  const sections = text.split(/^(## (?:User|Assistant) \(\d{2}:\d{2} UTC\))/m);
  let lastTeammate = null;

  for (let i = 1; i < sections.length; i += 2) {
    const header = sections[i];
    const body = sections[i + 1] || '';
    const hm = header.match(/## (User|Assistant) \((\d{2}:\d{2}) UTC\)/);
    if (!hm) continue;
    const [, role, time] = hm;

    const tm = body.match(/<teammate-message\s+teammate_id="([^"]+)"(?:\s+color="[^"]*")?(?:\s+summary="([^"]*)")?\s*>/);

    if (role === 'User' && tm) {
      const sender = tm[1], summary = tm[2] || '';
      const cm = body.match(/<teammate-message[^>]*>([\s\S]*?)<\/teammate-message>/);
      const content = cm ? cm[1].trim() : body.trim();
      let receiver = 'team-lead';
      const toM = summary.match(/\[to\s+([a-z][\w-]*)\]/i);
      if (toM) receiver = toM[1];
      const mtype = content.includes('"type": "idle_notification"') ? 'idle' : 'teammate';
      messages.push({ time, from: sender, to: receiver, content: content.slice(0, 800), summary, type: mtype });
      lastTeammate = sender;
    } else if (role === 'User') {
      const content = body.trim();
      if (content.length > 10) {
        messages.push({ time, from: 'user', to: 'team-lead', content: content.slice(0, 800), summary: '', type: 'user' });
        lastTeammate = null;
      }
    } else if (role === 'Assistant') {
      const lines = body.split('\n').filter(l => l.trim() && !l.trim().startsWith('- **Used'));
      if (lines.length > 0) {
        const receiver = lastTeammate || 'all';
        const mtype = body.includes('**Used SendMessage**') ? 'send' : 'response';
        messages.push({ time, from: 'team-lead', to: receiver, content: lines.join('\n').slice(0, 800), summary: '', type: mtype });
      }
    }
  }

  const name = filename.replace('.md', '');
  const participants = [...new Set(messages.flatMap(m => [m.from, ...(m.to !== 'all' ? [m.to] : [])]))];
  return {
    id: name, title: name.split('-').slice(4).join(' ') || name,
    metadata: {}, messages, participants, messageCount: messages.length, fileCount: 1
  };
}

// ─── Load Session ────────────────────────────────────────────────
function loadTranscript(t) {
  stop();
  state.current = t;
  state.messages = t.messages;
  state.index = -1;

  // Build participant list: include known agents + create entries for unknown ones
  const knownAgents = new Set(Object.keys(AGENTS));
  state.participants = [];
  for (const p of t.participants) {
    if (p === 'system') continue; // skip system messages
    if (!knownAgents.has(p)) {
      // Auto-register unknown agents with a generated color
      AGENTS[p] = {
        initials: p.slice(0, 2).toUpperCase(),
        color: '#' + Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0'),
        label: p.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase()),
        role: 'Agent'
      };
    }
    state.participants.push(p);
  }

  // Ensure team-lead is included if any teammate messages exist
  if (state.messages.some(m => m.type === 'teammate' || m.type === 'response') && !state.participants.includes('team-lead')) {
    state.participants.push('team-lead');
  }

  // Update session info
  const info = document.getElementById('session-info');
  const agentCount = state.participants.filter(p => p !== 'user' && p !== 'system').length;
  info.textContent = agentCount + ' agents \u00B7 ' + t.messageCount + ' messages' + (t.fileCount > 1 ? ' \u00B7 ' + t.fileCount + ' threads merged' : '');

  layoutAgents();
  renderMessageList();
  updateUI();
  clearCanvas();
}

// ─── Create SVG Avatar ───────────────────────────────────────────
function createAvatarSVG(agentId) {
  const iconSvg = AGENT_ICONS[agentId] || FALLBACK_ICON;
  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('viewBox', '0 0 24 24');
  svg.setAttribute('fill', 'none');
  svg.innerHTML = iconSvg;
  return svg;
}

// ─── Layout Agents in Circle ─────────────────────────────────────
function layoutAgents() {
  Object.values(state.agentNodes).forEach(n => n.remove());
  state.agentNodes = {};
  state.agentPositions = {};

  const wrap = document.getElementById('arena-wrap');
  const rect = wrap.getBoundingClientRect();
  const cx = rect.width / 2;
  const cy = rect.height / 2;
  const radius = Math.min(cx, cy) * 0.62;

  const display = state.participants.filter(a => a !== 'system');
  const count = display.length;

  display.forEach((id, i) => {
    const angle = (i / count) * Math.PI * 2 - Math.PI / 2;
    const x = cx + Math.cos(angle) * radius;
    const y = cy + Math.sin(angle) * radius;
    state.agentPositions[id] = { x, y };

    const agent = AGENTS[id] || { initials: '?', color: '#666', label: id, role: '' };
    const node = document.createElement('div');
    node.className = 'agent-node';
    node.style.left = x + 'px';
    node.style.top = y + 'px';
    node.style.setProperty('--agent-color', agent.color);
    node.dataset.agentId = id;

    const avatar = document.createElement('div');
    avatar.className = 'agent-avatar';
    avatar.style.background = agent.color + '22';
    avatar.style.borderColor = agent.color + '66';
    avatar.style.color = agent.color;
    avatar.appendChild(createAvatarSVG(id));

    const label = document.createElement('div');
    label.className = 'agent-label';
    label.textContent = agent.label;

    const role = document.createElement('div');
    role.className = 'agent-role';
    role.textContent = agent.role;

    node.appendChild(avatar);
    node.appendChild(label);
    node.appendChild(role);
    wrap.appendChild(node);
    state.agentNodes[id] = node;
  });
}

// ─── Canvas Drawing ──────────────────────────────────────────────
function clearCanvas() {
  const rect = canvas.parentElement.getBoundingClientRect();
  ctx.clearRect(0, 0, rect.width, rect.height);
}

function getControlPoint(from, to, cx, cy) {
  const mx = (from.x + to.x) / 2;
  const my = (from.y + to.y) / 2;
  const pull = 0.35;
  return { x: mx + (cx - mx) * pull, y: my + (cy - my) * pull };
}

function drawSelfLoop(pos, progress, color) {
  const rect = canvas.parentElement.getBoundingClientRect();
  clearCanvas();

  // Draw a loop that goes out from the agent and comes back
  const loopRadius = 40;
  const cx = rect.width / 2, cy = rect.height / 2;
  // Direction away from center
  const dx = pos.x - cx, dy = pos.y - cy;
  const dist = Math.sqrt(dx * dx + dy * dy) || 1;
  const nx = dx / dist, ny = dy / dist;
  const loopCx = pos.x + nx * loopRadius;
  const loopCy = pos.y + ny * loopRadius;

  // Full loop outline (faint)
  ctx.beginPath();
  ctx.arc(loopCx, loopCy, loopRadius, 0, Math.PI * 2);
  ctx.strokeStyle = color + '18';
  ctx.lineWidth = 2;
  ctx.stroke();

  if (progress > 0) {
    // Animated arc
    const startAngle = Math.atan2(pos.y - loopCy, pos.x - loopCx);
    const endAngle = startAngle + Math.PI * 2 * progress;
    ctx.beginPath();
    ctx.arc(loopCx, loopCy, loopRadius, startAngle, endAngle);
    ctx.strokeStyle = color;
    ctx.lineWidth = 2.5;
    ctx.shadowColor = color;
    ctx.shadowBlur = 8;
    ctx.stroke();
    ctx.shadowBlur = 0;

    // Dot at leading edge
    const dotX = loopCx + Math.cos(endAngle) * loopRadius;
    const dotY = loopCy + Math.sin(endAngle) * loopRadius;
    ctx.beginPath();
    ctx.arc(dotX, dotY, 5, 0, Math.PI * 2);
    ctx.fillStyle = '#fff';
    ctx.shadowColor = color;
    ctx.shadowBlur = 12;
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

function drawArc(fromPos, toPos, progress, color) {
  // Self-message: draw a loop
  if (fromPos === toPos || (fromPos.x === toPos.x && fromPos.y === toPos.y)) {
    drawSelfLoop(fromPos, progress, color);
    return;
  }

  const rect = canvas.parentElement.getBoundingClientRect();
  const cx = rect.width / 2, cy = rect.height / 2;
  const cp = getControlPoint(fromPos, toPos, cx, cy);

  clearCanvas();

  // Arc trail (faint)
  ctx.beginPath();
  ctx.moveTo(fromPos.x, fromPos.y);
  ctx.quadraticCurveTo(cp.x, cp.y, toPos.x, toPos.y);
  ctx.strokeStyle = color + '18';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Animated portion
  if (progress > 0) {
    const steps = 60;
    const endStep = Math.floor(progress * steps);
    ctx.beginPath();
    for (let s = 0; s <= endStep; s++) {
      const t = s / steps;
      const x = (1 - t) * (1 - t) * fromPos.x + 2 * (1 - t) * t * cp.x + t * t * toPos.x;
      const y = (1 - t) * (1 - t) * fromPos.y + 2 * (1 - t) * t * cp.y + t * t * toPos.y;
      if (s === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.strokeStyle = color;
    ctx.lineWidth = 2.5;
    ctx.shadowColor = color;
    ctx.shadowBlur = 8;
    ctx.stroke();
    ctx.shadowBlur = 0;

    // Dot at leading edge
    const t = progress;
    const dotX = (1 - t) * (1 - t) * fromPos.x + 2 * (1 - t) * t * cp.x + t * t * toPos.x;
    const dotY = (1 - t) * (1 - t) * fromPos.y + 2 * (1 - t) * t * cp.y + t * t * toPos.y;
    ctx.beginPath();
    ctx.arc(dotX, dotY, 5, 0, Math.PI * 2);
    ctx.fillStyle = '#fff';
    ctx.shadowColor = color;
    ctx.shadowBlur = 12;
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

// ─── Speech Bubble ───────────────────────────────────────────────
const bubble = document.getElementById('speech-bubble');

function showBubble(msg, receiverPos) {
  if (!receiverPos) { hideBubble(); return; }
  const agent = AGENTS[msg.from];
  bubble.querySelector('.bubble-from').textContent = agent?.label || msg.from;
  bubble.querySelector('.bubble-from').style.color = agent?.color || '#fff';

  const text = msg.summary || msg.content.slice(0, 160);
  bubble.querySelector('.bubble-text').textContent = text + (msg.content.length > 160 && !msg.summary ? '...' : '');

  const wrap = document.getElementById('arena-wrap').getBoundingClientRect();
  const cx = wrap.width / 2, cy = wrap.height / 2;
  const dx = cx - receiverPos.x, dy = cy - receiverPos.y;
  const dist = Math.sqrt(dx * dx + dy * dy) || 1;
  const offsetX = (dx / dist) * 70;
  const offsetY = (dy / dist) * 70;

  bubble.style.left = (receiverPos.x + offsetX) + 'px';
  bubble.style.top = (receiverPos.y + offsetY) + 'px';
  bubble.style.borderColor = agent?.color || '#334155';
  bubble.classList.add('visible');
}

function hideBubble() {
  bubble.classList.remove('visible');
}

// ─── Animation ───────────────────────────────────────────────────
function animateMessage(index) {
  const msg = state.messages[index];
  if (!msg) return;

  state.index = index;
  updateUI();

  // Highlight sender/receiver
  Object.values(state.agentNodes).forEach(n => n.classList.remove('sender', 'receiver'));
  if (state.agentNodes[msg.from]) state.agentNodes[msg.from].classList.add('sender');
  const toId = msg.to === 'all' ? null : msg.to;
  if (toId && state.agentNodes[toId]) state.agentNodes[toId].classList.add('receiver');

  const fromPos = state.agentPositions[msg.from];
  const toPos = toId ? state.agentPositions[toId] : null;
  const color = AGENTS[msg.from]?.color || '#fff';

  // Self-message
  const isSelf = msg.from === msg.to || (toId && toId === msg.from);
  if (isSelf && fromPos) {
    const arcDuration = (state.baseDelay / state.speed) * 0.4;
    const startTime = performance.now();
    // Also mark as receiver for glow
    if (state.agentNodes[msg.from]) state.agentNodes[msg.from].classList.add('receiver');
    function frame(now) {
      const elapsed = now - startTime;
      const progress = Math.min(elapsed / arcDuration, 1);
      drawSelfLoop(fromPos, progress, color);
      if (progress >= 0.7 && !bubble.classList.contains('visible')) {
        showBubble(msg, fromPos);
      }
      if (progress < 1) {
        state.animFrame = requestAnimationFrame(frame);
      } else {
        showBubble(msg, fromPos);
        scheduleNext();
      }
    }
    cancelAnimationFrame(state.animFrame);
    clearTimeout(state.timeout);
    state.animFrame = requestAnimationFrame(frame);
    return;
  }

  if (!fromPos || !toPos) {
    clearCanvas();
    if (fromPos) showBubble(msg, fromPos);
    scheduleNext();
    return;
  }

  const arcDuration = (state.baseDelay / state.speed) * 0.4;
  const startTime = performance.now();

  function frame(now) {
    const elapsed = now - startTime;
    const progress = Math.min(elapsed / arcDuration, 1);
    drawArc(fromPos, toPos, progress, color);

    if (progress >= 0.7 && !bubble.classList.contains('visible')) {
      showBubble(msg, toPos);
    }

    if (progress < 1) {
      state.animFrame = requestAnimationFrame(frame);
    } else {
      showBubble(msg, toPos);
      scheduleNext();
    }
  }

  cancelAnimationFrame(state.animFrame);
  clearTimeout(state.timeout);
  state.animFrame = requestAnimationFrame(frame);
}

function scheduleNext() {
  if (!state.playing) return;
  const holdDuration = (state.baseDelay / state.speed) * 0.6;
  state.timeout = setTimeout(() => {
    if (state.index < state.messages.length - 1) {
      animateMessage(state.index + 1);
    } else {
      stop();
    }
  }, holdDuration);
}

// ─── Playback Controls ──────────────────────────────────────────
function togglePlay() {
  if (state.playing) { pause(); } else { play(); }
}

function play() {
  if (!state.current || state.messages.length === 0) return;
  state.playing = true;
  document.getElementById('btn-play').textContent = 'Pause';
  document.getElementById('btn-play').classList.add('playing');
  const startIdx = state.index < 0 ? 0 : (state.index >= state.messages.length - 1 ? 0 : state.index + 1);
  animateMessage(startIdx);
}

function pause() {
  state.playing = false;
  cancelAnimationFrame(state.animFrame);
  clearTimeout(state.timeout);
  document.getElementById('btn-play').textContent = 'Play';
  document.getElementById('btn-play').classList.remove('playing');
}

function stop() {
  pause();
  hideBubble();
}

function stepNext() {
  pause();
  if (!state.current) return;
  const next = Math.min(state.index + 1, state.messages.length - 1);
  showMessageStatic(next);
}

function stepPrev() {
  pause();
  if (!state.current) return;
  const prev = Math.max(state.index - 1, 0);
  showMessageStatic(prev);
}

function showMessageStatic(index) {
  const msg = state.messages[index];
  if (!msg) return;
  state.index = index;

  Object.values(state.agentNodes).forEach(n => n.classList.remove('sender', 'receiver'));
  if (state.agentNodes[msg.from]) state.agentNodes[msg.from].classList.add('sender');
  const toId = msg.to === 'all' ? null : msg.to;
  if (toId && state.agentNodes[toId]) state.agentNodes[toId].classList.add('receiver');

  const fromPos = state.agentPositions[msg.from];
  const toPos = toId ? state.agentPositions[toId] : null;
  const color = AGENTS[msg.from]?.color || '#fff';

  const isSelf = msg.from === msg.to || (toId && toId === msg.from);
  if (isSelf && fromPos) {
    if (state.agentNodes[msg.from]) state.agentNodes[msg.from].classList.add('receiver');
    drawSelfLoop(fromPos, 1, color);
    showBubble(msg, fromPos);
  } else if (fromPos && toPos) {
    drawArc(fromPos, toPos, 1, color);
    showBubble(msg, toPos);
  } else if (fromPos) {
    clearCanvas();
    showBubble(msg, fromPos);
  } else {
    clearCanvas();
    hideBubble();
  }

  updateUI();
}

function jumpTo(index) {
  pause();
  showMessageStatic(index);
}

function updateSpeed() {
  const slider = document.getElementById('speed-slider');
  state.speed = parseFloat(slider.value);
  document.getElementById('speed-label').textContent = state.speed + 'x';
}

function handleTimelineClick(e) {
  if (!state.current || state.messages.length === 0) return;
  const rect = e.currentTarget.getBoundingClientRect();
  const pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
  const idx = Math.round(pct * (state.messages.length - 1));
  pause();
  showMessageStatic(idx);
}

// ─── UI Updates ──────────────────────────────────────────────────
function updateUI() {
  const total = state.messages.length;
  const idx = state.index;

  document.getElementById('counter-label').textContent = (idx >= 0 ? idx + 1 : 0) + ' / ' + total;
  document.getElementById('detail-counter').textContent = 'Message ' + (idx >= 0 ? idx + 1 : '-') + ' of ' + total;

  const pct = total > 0 && idx >= 0 ? ((idx / (total - 1)) * 100) : 0;
  document.getElementById('timeline-fill').style.width = pct + '%';
  document.getElementById('timeline-thumb').style.left = pct + '%';

  if (idx >= 0 && idx < total) {
    const msg = state.messages[idx];
    const fromAgent = AGENTS[msg.from];
    const toAgent = AGENTS[msg.to];
    const isSelf = msg.from === msg.to;

    document.getElementById('detail-time').textContent = msg.time + ' UTC';

    const routeEl = document.getElementById('detail-route');
    routeEl.innerHTML = '';
    const fromSpan = document.createElement('span');
    fromSpan.style.color = fromAgent?.color || '#fff';
    fromSpan.textContent = fromAgent?.label || msg.from;

    if (isSelf) {
      const selfBadge = document.createElement('span');
      selfBadge.style.cssText = 'font-size:10px;color:#a5b4fc;margin-left:8px;opacity:0.7;';
      selfBadge.textContent = '(self)';
      routeEl.append(fromSpan, selfBadge);
    } else {
      const arrow = document.createElement('span');
      arrow.className = 'arrow';
      arrow.textContent = ' \u2192 ';
      const toSpan = document.createElement('span');
      toSpan.style.color = toAgent?.color || '#fff';
      toSpan.textContent = msg.to === 'all' ? 'All' : (toAgent?.label || msg.to);
      routeEl.append(fromSpan, arrow, toSpan);
    }

    const typeEl = document.getElementById('detail-type');
    const typeColors = {
      teammate: '#10B981', response: '#6366F1', user: '#94A3B8',
      idle: '#475569', send: '#F59E0B'
    };
    typeEl.style.background = (typeColors[msg.type] || '#475569') + '33';
    typeEl.style.color = typeColors[msg.type] || '#94A3B8';
    typeEl.textContent = msg.type;

    document.getElementById('detail-content').textContent = msg.content;

    document.querySelectorAll('.msg-item').forEach((el, i) => {
      el.classList.toggle('active', i === idx);
    });
    const activeItem = document.querySelector('.msg-item.active');
    if (activeItem) activeItem.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
  }
}

function renderMessageList() {
  const wrap = document.getElementById('msg-list-wrap');
  wrap.innerHTML = '';

  state.messages.forEach((msg, i) => {
    const item = document.createElement('div');
    item.className = 'msg-item';
    item.onclick = () => jumpTo(i);

    const dot = document.createElement('div');
    dot.className = 'msg-dot';
    dot.style.background = AGENTS[msg.from]?.color || '#666';

    const route = document.createElement('span');
    route.className = 'msg-item-route';
    const fromInit = AGENTS[msg.from]?.initials || '?';
    const isSelf = msg.from === msg.to;
    if (isSelf) {
      route.textContent = fromInit + '\u21BB'; // loop arrow
    } else {
      const toInit = msg.to === 'all' ? 'ALL' : (AGENTS[msg.to]?.initials || '?');
      route.textContent = fromInit + '\u2192' + toInit;
    }
    route.style.color = AGENTS[msg.from]?.color || '#fff';

    const summary = document.createElement('span');
    summary.className = 'msg-item-summary';
    summary.textContent = msg.summary || msg.content.slice(0, 60).replace(/\n/g, ' ');

    const time = document.createElement('span');
    time.className = 'msg-item-time';
    time.textContent = msg.time;

    item.append(dot, route, summary, time);
    if (isSelf) {
      const badge = document.createElement('span');
      badge.className = 'msg-self-badge';
      badge.textContent = 'self';
      item.insertBefore(badge, time);
    }
    wrap.appendChild(item);
  });
}

// ─── Keyboard Shortcuts ──────────────────────────────────────────
document.addEventListener('keydown', e => {
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
  switch (e.key) {
    case ' ': e.preventDefault(); togglePlay(); break;
    case 'ArrowRight': case 'l': stepNext(); break;
    case 'ArrowLeft': case 'h': stepPrev(); break;
    case 'ArrowUp': case 'k':
      e.preventDefault();
      document.getElementById('speed-slider').stepUp();
      updateSpeed();
      break;
    case 'ArrowDown': case 'j':
      e.preventDefault();
      document.getElementById('speed-slider').stepDown();
      updateSpeed();
      break;
  }
});

// ─── Init ────────────────────────────────────────────────────────
resizeCanvas();
loadData();
</script>
</body>
</html>
