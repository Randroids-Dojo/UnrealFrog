<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Unreal Frog - 3D Frogger</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #000; overflow: hidden; font-family: 'Courier New', monospace; }
canvas { display: block; }
#hud {
  position: absolute; top: 0; left: 0; width: 100%; pointer-events: none;
  padding: 10px 20px;
}
#hud-top {
  display: flex; justify-content: space-between; align-items: center;
  font-size: 16px; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
}
#score { color: #00FF64; }
#hiscore { color: #FFFF00; }
#lives-wave { color: #FF6464; }
#timer-bar-container {
  margin-top: 6px; height: 8px; background: #141414DD;
  border-radius: 4px; overflow: hidden;
}
#timer-bar { height: 100%; width: 100%; transition: background-color 0.1s; border-radius: 4px; }
#overlay {
  position: absolute; top: 0; left: 0; width: 100%; height: 100%;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  pointer-events: none;
}
#overlay-bg {
  position: absolute; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(0,0,0,0); transition: background 0.3s;
}
.overlay-text {
  position: relative; z-index: 1; text-align: center;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.9);
}
#title-text {
  font-size: 64px; font-weight: bold; letter-spacing: 4px;
}
#subtitle-text {
  font-size: 24px; color: #fff; margin-top: 20px;
}
#hiscore-text {
  font-size: 20px; color: #FFFF00; margin-top: 10px;
}
#credits-text {
  font-size: 12px; color: #646464; margin-top: 60px;
}
#state-text {
  font-size: 48px; font-weight: bold; color: #FFFF00;
  padding: 15px 40px; background: rgba(0,0,0,0.7); border-radius: 8px;
}
#death-flash {
  position: absolute; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(255,0,0,0); pointer-events: none;
}
#wave-announce {
  position: absolute; top: 30%; left: 50%; transform: translate(-50%,-50%);
  font-size: 48px; font-weight: bold; color: #FFFF00;
  text-shadow: 2px 2px 6px rgba(0,0,0,0.9);
  pointer-events: none; opacity: 0;
}
.score-pop {
  position: absolute; font-size: 20px; font-weight: bold;
  text-shadow: 1px 1px 3px rgba(0,0,0,0.9);
  pointer-events: none;
}
#touch-controls {
  position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
  display: none; pointer-events: auto; opacity: 0.5;
}
#touch-controls button {
  width: 60px; height: 60px; font-size: 24px; border: 2px solid #fff;
  background: rgba(255,255,255,0.15); color: #fff; border-radius: 12px;
  cursor: pointer; -webkit-tap-highlight-color: transparent;
}
#touch-controls button:active { background: rgba(255,255,255,0.4); }
.touch-row { display: flex; justify-content: center; gap: 4px; }
</style>
</head>
<body>
<div id="hud">
  <div id="hud-top">
    <span id="score">SCORE: 00000</span>
    <span id="hiscore">HI: 00000</span>
    <span id="lives-wave">LIVES: 3  WAVE: 1</span>
  </div>
  <div id="timer-bar-container"><div id="timer-bar"></div></div>
</div>
<div id="overlay">
  <div id="overlay-bg"></div>
  <div id="title-text" class="overlay-text"></div>
  <div id="subtitle-text" class="overlay-text"></div>
  <div id="hiscore-text" class="overlay-text"></div>
  <div id="credits-text" class="overlay-text"></div>
  <div id="state-text" class="overlay-text" style="display:none;"></div>
</div>
<div id="death-flash"></div>
<div id="wave-announce"></div>
<div id="touch-controls">
  <div class="touch-row"><button id="btn-up">&#9650;</button></div>
  <div class="touch-row">
    <button id="btn-left">&#9664;</button>
    <button id="btn-down">&#9660;</button>
    <button id="btn-right">&#9654;</button>
  </div>
</div>

<script type="importmap">
{ "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js" } }
</script>
<script type="module">
import * as THREE from 'three';

// ─── CONSTANTS ───────────────────────────────────────────────────────────────
const GRID_COLS = 13, GRID_ROWS = 15, CELL = 1.0;
const HOP_DURATION = 0.15, HOP_ARC = 0.30;
const INPUT_BUFFER = 0.1;
const RESPAWN_DELAY = 1.0, DYING_DUR = 0.5, ROUND_DUR = 2.0, GAMEOVER_DELAY = 3.0;
const TIME_PER_LEVEL = 30.0;
const HOME_COLS = [1, 4, 6, 8, 11], HOME_ROW = 14;
const START_LIVES = 3, MAX_LIVES = 9;
const PTS_HOP = 10, PTS_HOME = 200, PTS_ROUND = 1000, PTS_TIME = 10;
const EXTRA_LIFE_THRESHOLD = 10000;
const MAX_MULTIPLIER = 5;
const SPEED_INC = 0.15, MAX_SPEED_MULT = 2.0;
const FROG_RADIUS = 0.34;
const RIVER_MIN = 7, RIVER_MAX = 12;

// ─── GAME STATE ──────────────────────────────────────────────────────────────
const State = { TITLE: 0, SPAWNING: 1, PLAYING: 2, DYING: 3, ROUND_COMPLETE: 4, GAME_OVER: 5, PAUSED: 6 };
let gameState = State.TITLE;
let score = 0, hiScore = 0, lives = START_LIVES, wave = 1;
let timer = TIME_PER_LEVEL, timerWarningPlayed = false;
let stateTimer = 0;
let multiplier = 1, maxRowReached = 0;
let nextExtraLife = EXTRA_LIFE_THRESHOLD;
let homeSlotsFilled = [false, false, false, false, false];

// Frog state
let frogGrid = { x: 6, y: 0 };
let frogWorldPos = new THREE.Vector3(0, 0, 0);
let isHopping = false, hopElapsed = 0;
let hopStart = new THREE.Vector3(), hopEnd = new THREE.Vector3();
let bufferedDir = null;
let currentPlatform = null;
let deathFlashAlpha = 0;

// ─── THREE.JS SETUP ─────────────────────────────────────────────────────────
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setClearColor(0x0a0a14);
document.body.prepend(renderer.domElement);

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x0a0a14, 0.02);

// Camera: top-down perspective
const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.set(6.5 * CELL, 7.0 * CELL, 22 * CELL);
camera.lookAt(6.5 * CELL, 7.0 * CELL, 0);

// Lighting
const ambientLight = new THREE.AmbientLight(0x404060, 0.8);
scene.add(ambientLight);
const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
dirLight.position.set(10, 15, 20);
scene.add(dirLight);
const fillLight = new THREE.DirectionalLight(0x4060ff, 0.3);
fillLight.position.set(-5, -5, 10);
scene.add(fillLight);

// ─── MATERIAL HELPER ────────────────────────────────────────────────────────
function mat(color) {
  return new THREE.MeshLambertMaterial({ color });
}
function matT(color, opacity) {
  return new THREE.MeshLambertMaterial({ color, transparent: true, opacity });
}

// ─── GROUND CONSTRUCTION ────────────────────────────────────────────────────
const ZONE_COLORS = {
  start: 0x33cc33, road: 0x4d4d4d, median: 0x33cc33,
  river: 0x1a4dcc, goalLower: 0xcc9919, goalUpper: 0x198019
};

function buildGround() {
  const group = new THREE.Group();
  for (let row = 0; row < GRID_ROWS; row++) {
    let color;
    if (row === 0) color = ZONE_COLORS.start;
    else if (row <= 5) color = ZONE_COLORS.road;
    else if (row === 6) color = ZONE_COLORS.median;
    else if (row <= 12) color = ZONE_COLORS.river;
    else if (row === 13) color = ZONE_COLORS.goalLower;
    else color = ZONE_COLORS.goalUpper;

    const geo = new THREE.BoxGeometry(GRID_COLS * CELL, CELL, 0.05);
    const mesh = new THREE.Mesh(geo, mat(color));
    mesh.position.set((GRID_COLS * CELL) / 2, row * CELL + CELL / 2, -0.025);
    group.add(mesh);

    // Road lane markings
    if (row >= 1 && row <= 5) {
      for (let c = 0; c < GRID_COLS; c++) {
        if (c % 2 === 0) {
          const stripe = new THREE.Mesh(
            new THREE.BoxGeometry(0.6, 0.04, 0.01),
            mat(0xffffff)
          );
          stripe.position.set(c * CELL + CELL / 2, row * CELL + CELL / 2, 0.01);
          group.add(stripe);
        }
      }
    }
  }

  // Sidewalk edges (rows 0, 6)
  [0, 6].forEach(row => {
    const edge = new THREE.Mesh(
      new THREE.BoxGeometry(GRID_COLS * CELL, 0.08, 0.12),
      mat(0xccccaa)
    );
    edge.position.set((GRID_COLS * CELL) / 2, row * CELL + CELL, 0.06);
    group.add(edge);
  });

  return group;
}
scene.add(buildGround());

// ─── HOME SLOTS ─────────────────────────────────────────────────────────────
const homeSlotMeshes = [];
function buildHomeSlots() {
  HOME_COLS.forEach((col, i) => {
    // Lily pad - flat cylinder
    const geo = new THREE.CylinderGeometry(0.35, 0.35, 0.06, 12);
    const mesh = new THREE.Mesh(geo, mat(0x4dcc4d));
    mesh.rotation.x = Math.PI / 2;
    mesh.position.set(col * CELL + CELL / 2, HOME_ROW * CELL + CELL / 2, 0.03);
    scene.add(mesh);
    homeSlotMeshes.push(mesh);
  });
}
buildHomeSlots();

const filledSlotMeshes = [];

// ─── FROG ───────────────────────────────────────────────────────────────────
function createFrog() {
  const group = new THREE.Group();
  // Body
  const body = new THREE.Mesh(new THREE.SphereGeometry(0.35, 16, 12), mat(0x19cc19));
  body.scale.set(1, 1, 0.7);
  body.position.z = 0.25;
  group.add(body);
  // Eyes
  [-0.15, 0.15].forEach(x => {
    const eye = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), mat(0xffffff));
    eye.position.set(x, 0.2, 0.45);
    group.add(eye);
    const pupil = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), mat(0x111111));
    pupil.position.set(x, 0.28, 0.47);
    group.add(pupil);
  });
  // Legs (back)
  [-0.3, 0.3].forEach(x => {
    const leg = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.3, 0.08), mat(0x15aa15));
    leg.position.set(x, -0.25, 0.15);
    group.add(leg);
  });
  return group;
}
const frog = createFrog();
scene.add(frog);

// ─── HAZARD & PLATFORM DEFINITIONS ─────────────────────────────────────────
const LANE_CONFIGS = [
  null, // row 0 - start
  { type: 'car',        dir: -1, speed: 1.5, width: 1, gap: 3, color: 0xe61919 },
  { type: 'truck',      dir:  1, speed: 1.0, width: 2, gap: 4, color: 0x991a1a },
  { type: 'car',        dir: -1, speed: 2.0, width: 1, gap: 2, color: 0xe61919 },
  { type: 'bus',        dir:  1, speed: 1.75,width: 2, gap: 3, color: 0xe68019 },
  { type: 'motorcycle', dir: -1, speed: 2.5, width: 1, gap: 2, color: 0xe6e619 },
  null, // row 6 - median
  { type: 'smallLog',   dir:  1, speed: 1.0, width: 2, gap: 2, color: 0x8c4d19, platform: true },
  { type: 'turtle',     dir: -1, speed: 0.8, width: 3, gap: 2, color: 0x198033, platform: true, submerge: true },
  { type: 'largeLog',   dir:  1, speed: 1.2, width: 4, gap: 2, color: 0x664d1a, platform: true },
  { type: 'smallLog',   dir: -1, speed: 1.0, width: 2, gap: 2, color: 0x8c4d19, platform: true },
  { type: 'turtle',     dir:  1, speed: 0.8, width: 3, gap: 2, color: 0x198033, platform: true, submerge: true },
  { type: 'largeLog',   dir: -1, speed: 1.5, width: 4, gap: 2, color: 0x664d1a, platform: true },
];

// ─── CREATE MODELS ──────────────────────────────────────────────────────────
function createCar(color) {
  const g = new THREE.Group();
  // Body
  const body = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 0.3), mat(color));
  body.position.z = 0.15;
  g.add(body);
  // Roof
  const roof = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.4, 0.2), mat(color));
  roof.position.set(0, 0, 0.35);
  g.add(roof);
  // Windshield
  const wind = new THREE.Mesh(new THREE.BoxGeometry(0.48, 0.1, 0.18), mat(0x88ccff));
  wind.position.set(0, 0.21, 0.35);
  g.add(wind);
  // Wheels
  [[-0.25, -0.3], [-0.25, 0.3], [0.25, -0.3], [0.25, 0.3]].forEach(([x, y]) => {
    const w = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.06, 8), mat(0x222222));
    w.rotation.x = Math.PI / 2;
    w.position.set(x, y, 0.08);
    g.add(w);
  });
  return g;
}

function createTruck(color) {
  const g = new THREE.Group();
  // Cab
  const cab = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.6, 0.4), mat(color));
  cab.position.set(0.55, 0, 0.2);
  g.add(cab);
  // Cargo
  const cargo = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.7, 0.5), mat(darken(color, 0.7)));
  cargo.position.set(-0.15, 0, 0.25);
  g.add(cargo);
  // Wheels
  [[-0.55, -0.35], [-0.55, 0.35], [0.55, -0.35], [0.55, 0.35]].forEach(([x, y]) => {
    const w = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.06, 8), mat(0x222222));
    w.rotation.x = Math.PI / 2;
    w.position.set(x, y, 0.1);
    g.add(w);
  });
  return g;
}

function createBus(color) {
  const g = new THREE.Group();
  const body = new THREE.Mesh(new THREE.BoxGeometry(1.7, 0.7, 0.45), mat(color));
  body.position.z = 0.225;
  g.add(body);
  // Windows
  for (let i = -3; i <= 3; i++) {
    const win = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.05, 0.15), mat(0x88ccff));
    win.position.set(i * 0.2, 0.36, 0.3);
    g.add(win);
  }
  // Wheels
  [[-0.6, -0.38], [-0.6, 0.38], [0.6, -0.38], [0.6, 0.38]].forEach(([x, y]) => {
    const w = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.06, 8), mat(0x222222));
    w.rotation.x = Math.PI / 2;
    w.position.set(x, y, 0.1);
    g.add(w);
  });
  return g;
}

function createMotorcycle(color) {
  const g = new THREE.Group();
  const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.3, 0.2), mat(color));
  body.position.z = 0.2;
  g.add(body);
  // Rider
  const rider = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.3), mat(0x333333));
  rider.position.set(0, 0, 0.4);
  g.add(rider);
  // Wheels
  [[-0.22, 0], [0.22, 0]].forEach(([x, y]) => {
    const w = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.04, 8), mat(0x222222));
    w.rotation.x = Math.PI / 2;
    w.position.set(x, y, 0.1);
    g.add(w);
  });
  return g;
}

function createLog(width, color) {
  const g = new THREE.Group();
  const geo = new THREE.CylinderGeometry(0.2, 0.2, width * CELL - 0.1, 8);
  const logMesh = new THREE.Mesh(geo, mat(color));
  logMesh.rotation.z = Math.PI / 2;
  logMesh.position.z = 0.2;
  g.add(logMesh);
  // Bark rings
  for (let i = 0; i < width; i++) {
    const ring = new THREE.Mesh(
      new THREE.TorusGeometry(0.18, 0.03, 6, 8),
      mat(darken(color, 0.6))
    );
    ring.position.set((i - (width - 1) / 2) * 0.8, 0, 0.2);
    ring.rotation.y = Math.PI / 2;
    g.add(ring);
  }
  return g;
}

function createTurtleGroup(width, color) {
  const g = new THREE.Group();
  const count = width;
  for (let i = 0; i < count; i++) {
    // Shell
    const shell = new THREE.Mesh(
      new THREE.SphereGeometry(0.3, 10, 8),
      mat(color)
    );
    shell.scale.set(1, 1, 0.5);
    shell.position.set((i - (count - 1) / 2) * 0.85, 0, 0.15);
    g.add(shell);
    // Head
    const head = new THREE.Mesh(new THREE.SphereGeometry(0.08, 6, 6), mat(0x2d8a4e));
    head.position.set((i - (count - 1) / 2) * 0.85, 0.28, 0.15);
    g.add(head);
  }
  g.userData.submerge = true;
  return g;
}

function darken(hex, factor) {
  const r = ((hex >> 16) & 0xff) * factor;
  const g = ((hex >> 8) & 0xff) * factor;
  const b = (hex & 0xff) * factor;
  return (Math.floor(r) << 16) | (Math.floor(g) << 8) | Math.floor(b);
}

// ─── LANE ENTITIES ──────────────────────────────────────────────────────────
let laneEntities = []; // Array of arrays per lane

function createEntityForLane(config) {
  switch (config.type) {
    case 'car': return createCar(config.color);
    case 'truck': return createTruck(config.color);
    case 'bus': return createBus(config.color);
    case 'motorcycle': return createMotorcycle(config.color);
    case 'smallLog': return createLog(config.width, config.color);
    case 'largeLog': return createLog(config.width, config.color);
    case 'turtle': return createTurtleGroup(config.width, config.color);
    default: return new THREE.Mesh(new THREE.BoxGeometry(config.width * CELL - 0.1, 0.6, 0.3), mat(config.color));
  }
}

function getEffectiveGap(baseGap) {
  const reduction = Math.floor((wave - 1) / 2);
  return Math.max(1, baseGap - reduction);
}

function getSpeedMultiplier() {
  return Math.min(MAX_SPEED_MULT, 1.0 + (wave - 1) * SPEED_INC);
}

function spawnLane(row) {
  const config = LANE_CONFIGS[row];
  if (!config) return [];
  const entities = [];
  const effectiveGap = getEffectiveGap(config.gap);
  const spacing = (config.width + effectiveGap) * CELL;
  const totalWidth = GRID_COLS * CELL;
  const count = Math.ceil(totalWidth / spacing) + 2;

  for (let i = 0; i < count; i++) {
    const mesh = createEntityForLane(config);
    const xOffset = i * spacing;
    mesh.position.set(xOffset, row * CELL + CELL / 2, 0);
    mesh.userData = {
      row, speed: config.speed * config.dir * getSpeedMultiplier(),
      width: config.width * CELL,
      platform: !!config.platform,
      canSubmerge: !!config.submerge,
      submergeTimer: Math.random() * 7, // stagger submerge phases
      submergeState: 'surface', // surface, warning, submerged
      dir: config.dir,
    };
    scene.add(mesh);
    entities.push(mesh);
  }
  return entities;
}

function spawnAllLanes() {
  // Remove old
  laneEntities.forEach(ents => ents.forEach(e => scene.remove(e)));
  laneEntities = [];
  for (let row = 0; row < GRID_ROWS; row++) {
    laneEntities.push(spawnLane(row));
  }
}

// ─── COLLISION & PLATFORM DETECTION ─────────────────────────────────────────
function findPlatformAt(pos) {
  for (let row = RIVER_MIN; row <= RIVER_MAX; row++) {
    const ents = laneEntities[row];
    if (!ents) continue;
    for (const ent of ents) {
      if (!ent.userData.platform) continue;
      if (ent.userData.submergeState === 'submerged') continue;
      const hw = ent.userData.width / 2;
      const ex = ent.position.x;
      if (pos.x >= ex - hw - FROG_RADIUS && pos.x <= ex + hw + FROG_RADIUS &&
          Math.abs(pos.y - ent.position.y) < CELL * 0.6) {
        return ent;
      }
    }
  }
  return null;
}

function checkRoadCollision(pos) {
  for (let row = 1; row <= 5; row++) {
    const ents = laneEntities[row];
    if (!ents) continue;
    if (Math.abs(pos.y - (row * CELL + CELL / 2)) > CELL * 0.45) continue;
    for (const ent of ents) {
      const hw = ent.userData.width / 2 * 0.8; // 80% hitbox for near-miss feel
      const ex = ent.position.x;
      if (pos.x >= ex - hw && pos.x <= ex + hw) return true;
    }
  }
  return false;
}

// ─── GRID HELPERS ───────────────────────────────────────────────────────────
function gridToWorld(gx, gy) {
  return new THREE.Vector3(gx * CELL + CELL / 2, gy * CELL + CELL / 2, 0);
}

function worldToGrid(pos) {
  return { x: Math.round(pos.x / CELL - 0.5), y: Math.round(pos.y / CELL - 0.5) };
}

function isValidGrid(gx, gy) {
  return gx >= 0 && gx < GRID_COLS && gy >= 0 && gy < GRID_ROWS;
}

// ─── INPUT ──────────────────────────────────────────────────────────────────
const keys = {};
let lastInputDir = null;

document.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (gameState === State.TITLE && !['F5', 'F11', 'F12'].includes(e.code)) {
    startGame();
    e.preventDefault();
    return;
  }
  if (gameState === State.GAME_OVER && stateTimer > GAMEOVER_DELAY) {
    resetToTitle();
    e.preventDefault();
    return;
  }
  if (e.code === 'KeyP' || e.code === 'Escape') {
    if (gameState === State.PLAYING) { gameState = State.PAUSED; updateOverlay(); }
    else if (gameState === State.PAUSED) { gameState = State.PLAYING; updateOverlay(); }
    e.preventDefault();
  }
  // Directions
  let dir = null;
  if (e.code === 'ArrowUp' || e.code === 'KeyW') dir = { x: 0, y: 1 };
  if (e.code === 'ArrowDown' || e.code === 'KeyS') dir = { x: 0, y: -1 };
  if (e.code === 'ArrowLeft' || e.code === 'KeyA') dir = { x: -1, y: 0 };
  if (e.code === 'ArrowRight' || e.code === 'KeyD') dir = { x: 1, y: 0 };
  if (dir && gameState === State.PLAYING) {
    if (!isHopping) tryHop(dir);
    else bufferedDir = dir;
    e.preventDefault();
  }
});

document.addEventListener('keyup', e => { keys[e.code] = false; });

// Touch controls
function setupTouch() {
  if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
    document.getElementById('touch-controls').style.display = 'block';
  }
  const dirs = { 'btn-up': {x:0,y:1}, 'btn-down': {x:0,y:-1}, 'btn-left': {x:-1,y:0}, 'btn-right': {x:1,y:0} };
  Object.entries(dirs).forEach(([id, dir]) => {
    const btn = document.getElementById(id);
    btn.addEventListener('touchstart', e => {
      e.preventDefault();
      if (gameState === State.TITLE) { startGame(); return; }
      if (gameState === State.GAME_OVER && stateTimer > GAMEOVER_DELAY) { resetToTitle(); return; }
      if (gameState === State.PLAYING) {
        if (!isHopping) tryHop(dir); else bufferedDir = dir;
      }
    });
  });
}
setupTouch();

// ─── MOVEMENT ───────────────────────────────────────────────────────────────
function tryHop(dir) {
  if (gameState !== State.PLAYING) return;
  const newGX = frogGrid.x + dir.x;
  const newGY = frogGrid.y + dir.y;
  if (!isValidGrid(newGX, newGY)) return;

  isHopping = true;
  hopElapsed = 0;

  // Use actual world position if on a platform
  if (currentPlatform) {
    hopStart.copy(frogWorldPos);
  } else {
    hopStart.copy(gridToWorld(frogGrid.x, frogGrid.y));
  }
  hopEnd.copy(gridToWorld(newGX, newGY));

  frogGrid.x = newGX;
  frogGrid.y = newGY;
  lastInputDir = dir;

  // Scoring
  if (dir.y > 0) {
    if (newGY > maxRowReached) {
      const pts = PTS_HOP * multiplier;
      addScore(pts);
      maxRowReached = newGY;
      multiplier = Math.min(multiplier + 1, MAX_MULTIPLIER);
      spawnScorePop(pts);
    }
  } else if (dir.y < 0) {
    multiplier = 1;
  }

  currentPlatform = null;
  playSound('hop');
}

function finishHop() {
  isHopping = false;
  frogWorldPos.copy(gridToWorld(frogGrid.x, frogGrid.y));
  frog.position.copy(frogWorldPos);

  // Check home slot
  if (frogGrid.y === HOME_ROW) {
    const slotIdx = HOME_COLS.indexOf(frogGrid.x);
    if (slotIdx >= 0 && !homeSlotsFilled[slotIdx]) {
      fillHomeSlot(slotIdx);
    } else {
      die('splash');
    }
    return;
  }

  // Check river
  if (frogGrid.y >= RIVER_MIN && frogGrid.y <= RIVER_MAX) {
    const plat = findPlatformAt(frogWorldPos);
    if (plat) {
      currentPlatform = plat;
    } else {
      die('splash');
      return;
    }
  }

  // Check road collision at landing
  if (frogGrid.y >= 1 && frogGrid.y <= 5) {
    if (checkRoadCollision(frogWorldPos)) {
      die('squish');
      return;
    }
  }

  // Process buffered input
  if (bufferedDir) {
    const bd = bufferedDir;
    bufferedDir = null;
    tryHop(bd);
  }
}

// ─── SCORING ────────────────────────────────────────────────────────────────
function addScore(pts) {
  score += pts;
  if (score >= nextExtraLife) {
    lives = Math.min(lives + 1, MAX_LIVES);
    nextExtraLife += EXTRA_LIFE_THRESHOLD;
    playSound('extraLife');
  }
  if (score > hiScore) hiScore = score;
}

// ─── HOME SLOTS ─────────────────────────────────────────────────────────────
function fillHomeSlot(idx) {
  homeSlotsFilled[idx] = true;
  addScore(PTS_HOME);
  spawnScorePop(PTS_HOME);
  playSound('homeSlot');

  // Visual indicator for filled slot
  const col = HOME_COLS[idx];
  const filledMesh = new THREE.Mesh(
    new THREE.SphereGeometry(0.3, 12, 8),
    mat(0x19cc19)
  );
  filledMesh.scale.set(1, 1, 0.5);
  filledMesh.position.set(col * CELL + CELL / 2, HOME_ROW * CELL + CELL / 2, 0.15);
  scene.add(filledMesh);
  filledSlotMeshes.push(filledMesh);

  // Sparkle VFX
  spawnSparkles(filledMesh.position);

  // Check round complete
  if (homeSlotsFilled.every(Boolean)) {
    roundComplete();
  } else {
    // Reset frog
    respawnFrog();
  }
}

function roundComplete() {
  const timeBonus = Math.floor(timer) * PTS_TIME;
  addScore(PTS_ROUND + timeBonus);
  spawnScorePop(PTS_ROUND + timeBonus);
  gameState = State.ROUND_COMPLETE;
  stateTimer = 0;
  playSound('roundComplete');
  showWaveAnnounce(wave + 1);
  updateOverlay();
}

// ─── DEATH ──────────────────────────────────────────────────────────────────
function die(type) {
  if (gameState !== State.PLAYING) return;
  lives--;
  gameState = State.DYING;
  stateTimer = 0;
  currentPlatform = null;
  deathFlashAlpha = 0.5;
  multiplier = 1;
  timerWarningPlayed = false;

  // Death VFX
  spawnDeathPuff(frogWorldPos.clone(), type);

  if (type === 'splash') playSound('splash');
  else if (type === 'squish') playSound('squish');
  else playSound('squish');

  updateOverlay();
}

function respawnFrog() {
  frogGrid = { x: 6, y: 0 };
  frogWorldPos.copy(gridToWorld(6, 0));
  frog.position.copy(frogWorldPos);
  isHopping = false;
  currentPlatform = null;
  bufferedDir = null;
  maxRowReached = 0;
  multiplier = 1;
}

// ─── GAME FLOW ──────────────────────────────────────────────────────────────
function startGame() {
  score = 0;
  lives = START_LIVES;
  wave = 1;
  timer = TIME_PER_LEVEL;
  timerWarningPlayed = false;
  nextExtraLife = EXTRA_LIFE_THRESHOLD;
  homeSlotsFilled = [false, false, false, false, false];
  filledSlotMeshes.forEach(m => scene.remove(m));
  filledSlotMeshes.length = 0;
  multiplier = 1;
  maxRowReached = 0;
  spawnAllLanes();
  respawnFrog();
  frog.visible = true;
  gameState = State.SPAWNING;
  stateTimer = 0;
  updateOverlay();
}

function nextWave() {
  wave++;
  timer = TIME_PER_LEVEL;
  timerWarningPlayed = false;
  homeSlotsFilled = [false, false, false, false, false];
  filledSlotMeshes.forEach(m => scene.remove(m));
  filledSlotMeshes.length = 0;
  // Update home slot visuals
  homeSlotMeshes.forEach(m => {
    m.material = mat(0x4dcc4d);
  });
  spawnAllLanes();
  respawnFrog();
  gameState = State.SPAWNING;
  stateTimer = 0;
  updateOverlay();
}

function resetToTitle() {
  gameState = State.TITLE;
  frog.visible = false;
  // Clear lane entities
  laneEntities.forEach(ents => ents.forEach(e => scene.remove(e)));
  laneEntities = [];
  filledSlotMeshes.forEach(m => scene.remove(m));
  filledSlotMeshes.length = 0;
  updateOverlay();
}

// ─── VFX ────────────────────────────────────────────────────────────────────
const vfxList = [];

function spawnDeathPuff(pos, type) {
  const colors = { squish: 0xff3333, splash: 0x3366ff, offscreen: 0xffff33, timeout: 0xff3333 };
  const color = colors[type] || 0xff3333;
  const g = new THREE.Group();
  for (let i = 0; i < 8; i++) {
    const angle = (i / 8) * Math.PI * 2;
    const p = new THREE.Mesh(new THREE.SphereGeometry(0.12, 6, 6), matT(color, 0.9));
    p.position.set(Math.cos(angle) * 0.1, Math.sin(angle) * 0.1, 0.3);
    p.userData.vx = Math.cos(angle) * 2;
    p.userData.vy = Math.sin(angle) * 2;
    p.userData.vz = 1 + Math.random();
    g.add(p);
  }
  g.position.copy(pos);
  scene.add(g);
  vfxList.push({ mesh: g, timer: 0, duration: 0.8, type: 'deathPuff' });
}

function spawnSparkles(pos) {
  const g = new THREE.Group();
  for (let i = 0; i < 6; i++) {
    const angle = (i / 6) * Math.PI * 2;
    const p = new THREE.Mesh(new THREE.SphereGeometry(0.06, 6, 6), matT(0xffd800, 0.9));
    p.position.set(Math.cos(angle) * 0.15, Math.sin(angle) * 0.15, 0.2);
    p.userData.vx = Math.cos(angle) * 1.5;
    p.userData.vy = Math.sin(angle) * 1.5;
    p.userData.vz = 2;
    g.add(p);
  }
  g.position.copy(pos);
  scene.add(g);
  vfxList.push({ mesh: g, timer: 0, duration: 1.0, type: 'sparkle' });
}

function updateVFX(dt) {
  for (let i = vfxList.length - 1; i >= 0; i--) {
    const v = vfxList[i];
    v.timer += dt;
    const t = v.timer / v.duration;
    if (t >= 1) {
      scene.remove(v.mesh);
      vfxList.splice(i, 1);
      continue;
    }
    v.mesh.children.forEach(child => {
      if (child.userData.vx !== undefined) {
        child.position.x += child.userData.vx * dt;
        child.position.y += child.userData.vy * dt;
        child.position.z += child.userData.vz * dt;
        child.userData.vz -= 5 * dt; // gravity
      }
      if (child.material && child.material.opacity !== undefined) {
        child.material.opacity = Math.max(0, 1 - t);
      }
      child.scale.setScalar(Math.max(0.01, 1 - t * 0.5));
    });
  }
}

// ─── SCORE POP UI ───────────────────────────────────────────────────────────
function spawnScorePop(pts) {
  const el = document.createElement('div');
  el.className = 'score-pop';
  el.textContent = `+${pts}`;
  el.style.color = pts > 100 ? '#ffffff' : '#ffff00';

  // Project frog position to screen
  const vec = frogWorldPos.clone();
  vec.project(camera);
  const x = (vec.x * 0.5 + 0.5) * window.innerWidth;
  const y = (-vec.y * 0.5 + 0.5) * window.innerHeight;
  el.style.left = x + 'px';
  el.style.top = y + 'px';

  document.body.appendChild(el);

  let elapsed = 0;
  const dur = 1.5;
  function animate() {
    elapsed += 1 / 60;
    const t = elapsed / dur;
    if (t >= 1) { el.remove(); return; }
    el.style.top = (y - 60 * t) + 'px';
    el.style.opacity = 1 - t;
    requestAnimationFrame(animate);
  }
  requestAnimationFrame(animate);
}

// ─── WAVE ANNOUNCEMENT ─────────────────────────────────────────────────────
function showWaveAnnounce(waveNum) {
  const el = document.getElementById('wave-announce');
  el.textContent = `WAVE ${waveNum}!`;
  el.style.opacity = 1;
  el.style.transform = 'translate(-50%, -50%) scale(2)';
  let elapsed = 0;
  function animate() {
    elapsed += 1 / 60;
    if (elapsed < 0.2) {
      el.style.opacity = elapsed / 0.2;
    } else if (elapsed < 1.5) {
      el.style.opacity = 1;
      const s = 2 - (elapsed - 0.2) / 1.3;
      el.style.transform = `translate(-50%, -50%) scale(${s})`;
    } else if (elapsed < 2.0) {
      el.style.opacity = 1 - (elapsed - 1.5) / 0.5;
    } else {
      el.style.opacity = 0;
      return;
    }
    requestAnimationFrame(animate);
  }
  requestAnimationFrame(animate);
}

// ─── OVERLAY ────────────────────────────────────────────────────────────────
function updateOverlay() {
  const bg = document.getElementById('overlay-bg');
  const title = document.getElementById('title-text');
  const sub = document.getElementById('subtitle-text');
  const his = document.getElementById('hiscore-text');
  const cred = document.getElementById('credits-text');
  const state = document.getElementById('state-text');

  title.textContent = '';
  sub.textContent = '';
  his.textContent = '';
  cred.textContent = '';
  state.style.display = 'none';
  bg.style.background = 'rgba(0,0,0,0)';

  switch (gameState) {
    case State.TITLE:
      bg.style.background = 'rgba(10,10,20,0.94)';
      title.textContent = 'UNREAL FROG';
      sub.textContent = 'PRESS ANY KEY TO START';
      if (hiScore > 0) his.textContent = `HI-SCORE: ${hiScore}`;
      cred.textContent = 'A MOB PROGRAMMING PRODUCTION';
      break;
    case State.SPAWNING:
      state.style.display = 'block';
      state.textContent = 'GET READY';
      break;
    case State.PAUSED:
      bg.style.background = 'rgba(0,0,0,0.6)';
      state.style.display = 'block';
      state.textContent = 'PAUSED';
      break;
    case State.DYING:
      state.style.display = 'block';
      state.textContent = 'OOPS!';
      break;
    case State.ROUND_COMPLETE:
      state.style.display = 'block';
      state.textContent = 'ROUND COMPLETE!';
      break;
    case State.GAME_OVER:
      bg.style.background = 'rgba(0,0,0,0.7)';
      state.style.display = 'block';
      state.textContent = 'GAME OVER';
      break;
    case State.PLAYING:
      break;
  }
}

// ─── AUDIO ──────────────────────────────────────────────────────────────────
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function playTone(freq, dur, type = 'square', vol = 0.15) {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
  gain.gain.setValueAtTime(vol, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + dur);
}

function playSound(name) {
  if (audioCtx.state === 'suspended') audioCtx.resume();
  switch (name) {
    case 'hop':
      playTone(440, 0.05, 'square', 0.1);
      break;
    case 'squish':
      playTone(150, 0.3, 'sawtooth', 0.2);
      setTimeout(() => playTone(80, 0.2, 'sawtooth', 0.15), 100);
      break;
    case 'splash':
      // White noise burst
      const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.3, audioCtx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i = 0; i < data.length; i++) {
        data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (audioCtx.sampleRate * 0.1));
      }
      const src = audioCtx.createBufferSource();
      const g = audioCtx.createGain();
      src.buffer = buf;
      g.gain.value = 0.2;
      src.connect(g);
      g.connect(audioCtx.destination);
      src.start();
      break;
    case 'homeSlot':
      playTone(523, 0.1, 'square', 0.12);
      setTimeout(() => playTone(659, 0.1, 'square', 0.12), 80);
      setTimeout(() => playTone(784, 0.15, 'square', 0.12), 160);
      break;
    case 'roundComplete':
      [523, 659, 784, 1047].forEach((f, i) => {
        setTimeout(() => playTone(f, 0.2, 'square', 0.15), i * 120);
      });
      break;
    case 'extraLife':
      [784, 988, 1175, 1318].forEach((f, i) => {
        setTimeout(() => playTone(f, 0.15, 'triangle', 0.12), i * 100);
      });
      break;
    case 'timerWarning':
      playTone(880, 0.1, 'square', 0.2);
      setTimeout(() => playTone(880, 0.1, 'square', 0.2), 200);
      break;
    case 'gameOver':
      [440, 370, 330, 262].forEach((f, i) => {
        setTimeout(() => playTone(f, 0.3, 'sawtooth', 0.15), i * 200);
      });
      break;
  }
}

// ─── HUD UPDATE ─────────────────────────────────────────────────────────────
function updateHUD() {
  document.getElementById('score').textContent = `SCORE: ${String(score).padStart(5, '0')}`;
  document.getElementById('hiscore').textContent = `HI: ${String(hiScore).padStart(5, '0')}`;
  document.getElementById('lives-wave').textContent = `LIVES: ${lives}  WAVE: ${wave}`;

  // Timer bar
  const pct = Math.max(0, timer / TIME_PER_LEVEL);
  const bar = document.getElementById('timer-bar');
  bar.style.width = (pct * 100) + '%';

  if (pct > 0.5) {
    bar.style.backgroundColor = `rgb(${Math.floor((1 - pct) * 2 * 255)}, ${Math.floor(pct * 255)}, 0)`;
  } else {
    bar.style.backgroundColor = `rgb(255, ${Math.floor(pct * 2 * 255)}, 0)`;
  }

  // Pulse when low
  const container = document.getElementById('timer-bar-container');
  if (pct < 0.167 && gameState === State.PLAYING) {
    const pulse = Math.sin(Date.now() * 0.006) * 0.5 + 0.5;
    container.style.height = (8 + pulse * 6) + 'px';
    bar.style.backgroundColor = `rgb(${180 + Math.floor(pulse * 75)}, 0, 0)`;
  } else {
    container.style.height = '8px';
  }

  // Death flash
  const flash = document.getElementById('death-flash');
  if (deathFlashAlpha > 0) {
    flash.style.background = `rgba(255, 0, 0, ${deathFlashAlpha})`;
  } else {
    flash.style.background = 'rgba(255, 0, 0, 0)';
  }

  // Title pulse
  if (gameState === State.TITLE) {
    const t = Date.now() * 0.001;
    const pulse = Math.sin(t * 1.5 * Math.PI * 2) * 0.5 + 0.5;
    const r = Math.floor(pulse * 255);
    const g = 255;
    const b = Math.floor((1 - pulse) * 100);
    document.getElementById('title-text').style.color = `rgb(${r},${g},${b})`;

    const blink = Math.sin(t * 2 * Math.PI * 2) > 0;
    document.getElementById('subtitle-text').style.opacity = blink ? 1 : 0;
  }
}

// ─── TURTLE SUBMERGE ────────────────────────────────────────────────────────
function updateTurtleSubmerge(dt) {
  if (wave < 2) return; // No submerging in wave 1

  for (let row = RIVER_MIN; row <= RIVER_MAX; row++) {
    const ents = laneEntities[row];
    if (!ents) continue;
    for (const ent of ents) {
      if (!ent.userData.canSubmerge) continue;
      ent.userData.submergeTimer += dt;
      const total = 4.0 + 1.0 + 2.0; // surface + warning + submerged
      const phase = ent.userData.submergeTimer % total;

      if (phase < 4.0) {
        ent.userData.submergeState = 'surface';
        ent.visible = true;
        ent.children.forEach(c => {
          if (c.material) c.material.opacity = 1;
        });
      } else if (phase < 5.0) {
        ent.userData.submergeState = 'warning';
        ent.visible = true;
        const bobT = (phase - 4.0) / 1.0;
        ent.children.forEach(c => {
          if (c.material) {
            c.material.transparent = true;
            c.material.opacity = 0.5 + Math.sin(bobT * 10) * 0.2;
          }
        });
      } else {
        ent.userData.submergeState = 'submerged';
        ent.visible = false;
      }
    }
  }
}

// ─── MAIN UPDATE ────────────────────────────────────────────────────────────
let lastTime = performance.now();

function update() {
  requestAnimationFrame(update);

  const now = performance.now();
  const dt = Math.min((now - lastTime) / 1000, 0.05); // Cap at 50ms
  lastTime = now;

  // State timer
  stateTimer += dt;

  // Death flash decay
  if (deathFlashAlpha > 0) {
    deathFlashAlpha = Math.max(0, deathFlashAlpha - 1.67 * dt);
  }

  // Update VFX
  updateVFX(dt);

  switch (gameState) {
    case State.TITLE:
      break;

    case State.SPAWNING:
      frog.visible = Math.sin(stateTimer * 15) > 0; // Blink
      if (stateTimer >= RESPAWN_DELAY) {
        frog.visible = true;
        gameState = State.PLAYING;
        updateOverlay();
      }
      break;

    case State.PLAYING:
      updateLanes(dt);
      updateTurtleSubmerge(dt);
      updateFrogHop(dt);
      updateFrogRiding(dt);
      updateTimer(dt);
      checkContinuousCollisions();
      break;

    case State.DYING:
      frog.visible = false;
      if (stateTimer >= DYING_DUR) {
        if (lives > 0) {
          respawnFrog();
          gameState = State.SPAWNING;
          stateTimer = 0;
        } else {
          gameState = State.GAME_OVER;
          stateTimer = 0;
          playSound('gameOver');
        }
        updateOverlay();
      }
      break;

    case State.ROUND_COMPLETE:
      updateLanes(dt);
      if (stateTimer >= ROUND_DUR) {
        nextWave();
      }
      break;

    case State.GAME_OVER:
      break;

    case State.PAUSED:
      break;
  }

  updateHUD();
  renderer.render(scene, camera);
}

function updateLanes(dt) {
  for (let row = 0; row < GRID_ROWS; row++) {
    const ents = laneEntities[row];
    if (!ents || ents.length === 0) continue;
    const config = LANE_CONFIGS[row];
    if (!config) continue;

    for (const ent of ents) {
      ent.position.x += ent.userData.speed * dt;
    }

    // Wrapping
    const totalWidth = GRID_COLS * CELL;
    const buffer = ent => ent.userData.width;
    for (const ent of ents) {
      if (ent.userData.speed > 0 && ent.position.x > totalWidth + buffer(ent)) {
        ent.position.x -= totalWidth + buffer(ent) * 2 + getEffectiveGap(config.gap) * CELL;
      }
      if (ent.userData.speed < 0 && ent.position.x < -buffer(ent)) {
        ent.position.x += totalWidth + buffer(ent) * 2 + getEffectiveGap(config.gap) * CELL;
      }
    }
  }
}

function updateFrogHop(dt) {
  if (!isHopping) return;
  hopElapsed += dt;
  const t = Math.min(hopElapsed / HOP_DURATION, 1.0);

  // Linear XY interpolation
  frogWorldPos.x = hopStart.x + (hopEnd.x - hopStart.x) * t;
  frogWorldPos.y = hopStart.y + (hopEnd.y - hopStart.y) * t;
  // Parabolic arc
  frogWorldPos.z = HOP_ARC * 4 * t * (1 - t);

  frog.position.copy(frogWorldPos);

  // Squash and stretch
  const squash = 1 + Math.sin(t * Math.PI) * 0.2;
  frog.scale.set(1, 1, squash);

  if (t >= 1.0) {
    frogWorldPos.z = 0;
    frog.scale.set(1, 1, 1);
    finishHop();
  }
}

function updateFrogRiding(dt) {
  if (isHopping || !currentPlatform) return;
  // Move frog with platform
  frogWorldPos.x += currentPlatform.userData.speed * dt;
  frog.position.copy(frogWorldPos);
  frogGrid = worldToGrid(frogWorldPos);

  // Check off-screen death
  if (frogWorldPos.x < -CELL || frogWorldPos.x > (GRID_COLS + 1) * CELL) {
    die('offscreen');
  }

  // Check if platform submerged
  if (currentPlatform.userData.submergeState === 'submerged') {
    die('splash');
  }
}

function updateTimer(dt) {
  timer -= dt;
  if (timer <= 5 && !timerWarningPlayed) {
    playSound('timerWarning');
    timerWarningPlayed = true;
  }
  if (timer <= 0) {
    timer = 0;
    die('timeout');
  }
}

function checkContinuousCollisions() {
  if (isHopping || gameState !== State.PLAYING) return;
  // Road collision while stationary
  if (frogGrid.y >= 1 && frogGrid.y <= 5) {
    if (checkRoadCollision(frogWorldPos)) {
      die('squish');
    }
  }
}

// ─── RESIZE ─────────────────────────────────────────────────────────────────
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// ─── INIT ───────────────────────────────────────────────────────────────────
frog.visible = false;
updateOverlay();
update();

</script>
</body>
</html>
